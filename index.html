<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fullscreen View</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; padding: 0; background: #000; color: #fff; font-family: system-ui, Arial; cursor: none; overflow: hidden; }

  #preloadScreen {
    position: fixed; inset: 0; z-index: 9999;
    background: #0a0a0a;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 28px;
    transition: opacity 0.6s ease;
  }
  #preloadScreen.fade-out { opacity: 0; pointer-events: none; }
  #preloadLogo  { font-size: 15px; font-weight: 700; letter-spacing: 0.18em; text-transform: uppercase; color: #555; }
  #preloadTitle { font-size: 22px; font-weight: 700; letter-spacing: 0.04em; color: #fff; }
  #preloadBarWrap  { width: 320px; max-width: 80vw; }
  #preloadBarTrack { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; }
  #preloadBarFill  { height: 100%; width: 0%; background: #fff; border-radius: 3px; transition: width 0.25s ease; }
  #preloadStatus   { margin-top: 10px; font-size: 12px; color: #555; letter-spacing: 0.05em; text-align: center; min-height: 18px; }

  .canvas { position: fixed; inset: 0; background: #000; }
  .slide  { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 800ms ease; }
  .slide.visible { opacity: 1; pointer-events: auto; }
  .slide img   { max-width: 100%; max-height: 100%; object-fit: contain; }
  .slide video { max-width: 100%; max-height: 100%; object-fit: contain; }

  .yt-container { position: absolute; inset: 0; }
  .yt-container iframe { width: 100%; height: 100%; border: none; display: block; }

  @keyframes bannerIn {
    from { transform: translateX(-110%); }
    to   { transform: translateX(0); }
  }
  .overlay {
    position: absolute; top: 0; left: 0;
    padding: 18px 40px 18px 28px;
    border-radius: 0 0 12px 0;
    font-size: 28px; font-weight: 800; letter-spacing: 0.03em; line-height: 1.3;
    z-index: 100; max-width: 80vw; word-break: break-word;
    box-shadow: 6px 6px 0 rgba(0,0,0,0.35);
    display: none;
  }
  .overlay.animate-in { animation: bannerIn 0.55s cubic-bezier(0.22, 1, 0.36, 1) both; }
</style>
</head>
<body>

<div id="preloadScreen">
  <div id="preloadLogo">Innovate</div>
  <div id="preloadTitle">Loading Elements</div>
  <div id="preloadBarWrap">
    <div id="preloadBarTrack"><div id="preloadBarFill"></div></div>
    <div id="preloadStatus">Connecting…</div>
  </div>
</div>

<div class="canvas" id="canvas" style="opacity:0;transition:opacity 0.6s ease"></div>
<div class="overlay" id="overlay"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, onValue, get } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const canvas        = document.getElementById("canvas");
const overlayEl     = document.getElementById("overlay");
const preloadScreen = document.getElementById("preloadScreen");
const preloadFill   = document.getElementById("preloadBarFill");
const preloadStatus = document.getElementById("preloadStatus");

let mediaCache     = {};
let slideEls       = [];   // pre-built slide elements, including video elements already streaming
let presentation   = null;
let slideIndex     = 0;
let slideTimer     = null;
let ytPlayers      = {};
let ytApiReady     = false;
let ytApiLoading   = false;
let pendingYtInits = [];
let overlayShown   = false;

// ── Refresh signal ────────────────────────────────────────────
let refreshSkipped = false;
onValue(ref(db, "refreshSignal"), function() {
  if (!refreshSkipped) { refreshSkipped = true; return; }
  location.reload(true);
});

function setProgress(pct, label) {
  preloadFill.style.width = Math.min(100, Math.max(0, pct)) + "%";
  if (label !== undefined) preloadStatus.textContent = label;
}

function dismissPreload() {
  preloadScreen.classList.add("fade-out");
  canvas.style.opacity = "1";
  setTimeout(function() { preloadScreen.style.display = "none"; }, 650);
}

function sleep(ms) { return new Promise(function(r) { setTimeout(r, ms); }); }

/**
 * Wait for a video element to be ready to play from a given time with no stall.
 * We mimic "open in new tab" behaviour:
 *   - src is set directly (browser uses range requests, no CORS issues)
 *   - we seek to startTime
 *   - we wait for readyState >= HAVE_FUTURE_DATA (3) which means
 *     "enough data to play from current position without immediately stalling"
 * This is exactly what happens when you open a video in a new tab.
 */
function waitForVideoReady(vid, startTime) {
  return new Promise(function(resolve) {
    var st = startTime || 0;
    var done = false;

    var finish = function() {
      if (done) return;
      done = true;
      resolve();
    };

    // Hard timeout — move on after 12s regardless
    var timeout = setTimeout(finish, 12000);

    var checkReady = function() {
      // readyState 3 = HAVE_FUTURE_DATA: can play without stalling right now
      if (vid.readyState >= 3) {
        clearTimeout(timeout);
        finish();
        return;
      }
      vid.addEventListener("canplay", function() {
        clearTimeout(timeout);
        finish();
      }, { once: true });
    };

    var seekAndWait = function() {
      if (done) return;
      try {
        if (st > 0 && isFinite(vid.duration) && st < vid.duration) {
          vid.currentTime = st;
        }
      } catch(e) {}
      checkReady();
    };

    if (vid.readyState >= 1) {
      // Already have metadata — seek and wait
      seekAndWait();
    } else {
      vid.addEventListener("loadedmetadata", seekAndWait, { once: true });
    }

    vid.load();
  });
}

/**
 * Wait for an image to fully load.
 */
function waitForImageReady(img) {
  return new Promise(function(resolve) {
    if (img.complete && img.naturalWidth > 0) { resolve(); return; }
    img.addEventListener("load",  resolve, { once: true });
    img.addEventListener("error", resolve, { once: true });
  });
}

// ── Boot ──────────────────────────────────────────────────────
async function boot() {
  setProgress(0, "Connecting to database…");

  var results = await Promise.all([
    get(ref(db, "media")),
    get(ref(db, "activePresentation"))
  ]);

  mediaCache = results[0].val() || {};
  var activeId = results[1].val();

  var p = null;
  if (activeId) { var s1 = await get(ref(db, "presentations/" + activeId)); p = s1.val(); }
  if (!p)       { var s2 = await get(ref(db, "presentations/current"));    p = s2.val(); }

  if (!p || !p.items || !p.items.length) {
    setProgress(100, "No presentation found.");
    setTimeout(dismissPreload, 1200);
    return;
  }

  presentation = p;

  // ── Build ALL slide elements up-front and add them to the canvas ──
  // This is key: video elements are in the real DOM with their src set,
  // so the browser starts fetching via range requests immediately —
  // exactly like opening in a new tab.
  canvas.innerHTML = "";
  slideEls = [];

  p.items.forEach(function(it, idx) {
    var m = mediaCache[it.mediaId];
    var slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;

    if (!m) {
      slide.innerHTML = "<div style='color:#fff;font-size:24px'>Missing: " + it.mediaId + "</div>";
    } else if (m.resource_type === "youtube") {
      var wrap = document.createElement("div");
      wrap.className = "yt-container";
      var div = document.createElement("div");
      div.id = "yt-player-" + idx;
      wrap.appendChild(div);
      slide.appendChild(wrap);
    } else if (m.resource_type === "image") {
      var img = document.createElement("img");
      img.src = m.url;
      slide.appendChild(img);
    } else {
      // VIDEO: set src immediately so the browser starts range-fetching now
      var vid = document.createElement("video");
      vid.src = m.url;
      vid.preload = "auto";
      vid.muted = true;           // muted so browser allows early play/buffering
      vid.setAttribute("playsinline", "");
      vid.controls = false;
      slide.appendChild(vid);
    }

    canvas.appendChild(slide);   // in the real DOM = browser starts fetching
    slideEls.push(slide);
  });

  // ── Now wait for each media item to be ready, showing progress ──
  var total = p.items.length;
  var ready = 0;

  // Collect promises for all media items
  var promises = p.items.map(function(it, idx) {
    var m = mediaCache[it.mediaId];
    if (!m || m.resource_type === "youtube") {
      // YouTube: nothing to preload here
      return Promise.resolve();
    }

    var slide = slideEls[idx];

    if (m.resource_type === "image") {
      var img = slide.querySelector("img");
      return waitForImageReady(img).then(function() {
        ready++;
        setProgress((ready / total) * 95, "Loading " + ready + " / " + total);
      });
    } else {
      // Video
      var vid = slide.querySelector("video");
      var startTime = it.start || 0;
      return waitForVideoReady(vid, startTime).then(function() {
        ready++;
        setProgress((ready / total) * 95, "Buffering " + ready + " / " + total);
      });
    }
  });

  setProgress(2, "Loading 0 / " + total);

  // Wait for ALL media to be ready in parallel
  await Promise.all(promises);

  setProgress(100, "Ready — launching…");
  await sleep(300);
  dismissPreload();
  applyOverlay(p, true);
  listenForChanges();
  showSlide(p, 0);
}

// ── Live updates ──────────────────────────────────────────────
function listenForChanges() {
  onValue(ref(db, "activePresentation"), async function(snap) {
    var activeId = snap.val();
    var p = null;
    if (activeId) { var s1 = await get(ref(db, "presentations/" + activeId)); p = s1.val(); }
    if (!p)       { var s2 = await get(ref(db, "presentations/current"));    p = s2.val(); }
    if (!p) return;

    var oldIds = (presentation && presentation.items ? presentation.items : []).map(function(i) { return i.mediaId; }).join(",");
    var newIds = (p.items || []).map(function(i) { return i.mediaId; }).join(",");
    if (oldIds !== newIds) { location.reload(true); return; }

    presentation = p;
    applyOverlay(p, false);
  });
}

// ── Overlay ───────────────────────────────────────────────────
function applyOverlay(p, firstShow) {
  var ov = p.overlay || {};
  overlayEl.style.background = ov.color     || "#cc0000";
  overlayEl.style.color      = ov.textColor || "#ffffff";
  overlayEl.textContent      = ov.text      || "";

  if (ov.visible) {
    overlayEl.style.display = "block";
    if (firstShow && !overlayShown) {
      overlayEl.classList.remove("animate-in");
      void overlayEl.offsetWidth;
      overlayEl.classList.add("animate-in");
      overlayShown = true;
    }
  } else {
    overlayEl.style.display = "none";
    overlayShown = false;
  }
}

// ── Slide navigation ──────────────────────────────────────────
function showSlide(p, idx) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (!p || !p.items || !p.items.length) return;
  idx = ((idx % p.items.length) + p.items.length) % p.items.length;
  slideIndex = idx;

  var slides = Array.from(canvas.querySelectorAll(".slide"));

  // Pause all other slides
  slides.forEach(function(s) {
    var i = parseInt(s.dataset.idx, 10);
    if (i === idx) return;
    s.classList.remove("visible");
    var v = s.querySelector("video");
    if (v) { v.pause(); v.onended = null; }
    var pl = ytPlayers[i];
    if (pl) { try { pl.pauseVideo(); } catch(e) {} }
  });

  var slide = null;
  for (var i = 0; i < slides.length; i++) {
    if (parseInt(slides[i].dataset.idx, 10) === idx) { slide = slides[i]; break; }
  }
  if (!slide) return;

  slide.style.transition = p.transition === "cut" ? "none" : "opacity 800ms ease";
  void slide.offsetWidth;
  slide.classList.add("visible");

  var item  = p.items[idx];
  var media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }

  if (media.resource_type === "youtube") {
    playYT(p, idx, item, media);
  } else if (media.resource_type !== "image") {
    var vid = slide.querySelector("video");
    if (vid) playVideo(p, slide, vid, item);
    else scheduleNext(p);
  } else {
    // Image — just schedule next
    scheduleNext(p);
  }
}

// ── Video playback ────────────────────────────────────────────
function playVideo(p, slideEl, vid, item) {
  var start = item.start || 0;
  var end   = item.end   || null;
  vid.onended = null;
  vid.onloadedmetadata = null;

  // Unmute now that we're playing for real
  vid.muted = false;

  try {
    if (isFinite(vid.duration) && start < vid.duration) {
      vid.currentTime = Math.min(start, vid.duration - 0.01);
    }
  } catch(e) {}

  vid.play().catch(function() {});

  if (end && end > start) {
    var poll = function() {
      if (!slideEl.classList.contains("visible")) return;
      if (vid.currentTime >= end) { vid.pause(); advance(p); }
      else requestAnimationFrame(poll);
    };
    requestAnimationFrame(poll);
  } else {
    vid.onended = function() { advance(p); };
  }
}

// ── YouTube ───────────────────────────────────────────────────
function loadYtApi(cb) {
  if (ytApiReady) { cb(); return; }
  pendingYtInits.push(cb);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = function() {
    ytApiReady = true;
    pendingYtInits.forEach(function(fn) { fn(); });
    pendingYtInits = [];
  };
  var tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

function playYT(p, idx, item, media) {
  var start = (item.start != null) ? item.start : ((media.start != null) ? media.start : 0);
  var end   = (item.end   != null) ? item.end   : ((media.end   != null) ? media.end   : null);

  var init = function() {
    if (ytPlayers[idx]) {
      var pl = ytPlayers[idx];
      try { pl.seekTo(start, true); pl.playVideo(); } catch(e) {}
      if (end && end > start) pollYt(p, idx, pl, end);
      return;
    }
    var divId = "yt-player-" + idx;
    if (!document.getElementById(divId)) return;
    new window.YT.Player(divId, {
      videoId: media.ytId,
      playerVars: { autoplay:1, controls:0, disablekb:1, modestbranding:1, rel:0, start: Math.floor(start), mute:0, playsinline:1, enablejsapi:1 },
      events: {
        onReady: function(e) {
          ytPlayers[idx] = e.target;
          try { e.target.seekTo(start, true); } catch(err) {}
          e.target.playVideo();
          if (end && end > start) pollYt(p, idx, e.target, end);
        },
        onStateChange: function(e) { if (e.data === 0) advance(p); }
      }
    });
  };
  loadYtApi(init);
}

function pollYt(p, idx, player, end) {
  var check = function() {
    var slide = canvas.querySelector(".slide[data-idx=\"" + idx + "\"]");
    if (!slide || !slide.classList.contains("visible")) return;
    try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advance(p); return; } } catch(e) {}
    requestAnimationFrame(check);
  };
  requestAnimationFrame(check);
}

function advance(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  showSlide(p, (slideIndex + 1) % (p.items.length || 1));
}

var timerSetAt = null;

function scheduleNext(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  var interval = p.intervalMs || 5000;
  timerSetAt = Date.now();
  slideTimer = setTimeout(function() {
    timerSetAt = null;
    showSlide(p, (slideIndex + 1) % (p.items.length || 1));
  }, interval);
}

// ── Tab visibility handling ───────────────────────────────────
// When hidden: pause the current video and freeze the slide timer.
// When visible again: resume from exactly where we left off —
// don't re-seek, don't restart the slide, just unpause.
var hiddenAt      = null;   // timestamp when tab was hidden
var pausedForHide = false;  // did WE pause the video (vs it was already paused)
var timerRemainingMs = null; // how much time was left on the slide timer

document.addEventListener("visibilitychange", function() {
  if (!presentation) return;

  if (document.visibilityState === "hidden") {
    // ── Going to background ───────────────────────────────────
    hiddenAt = Date.now();

    // Freeze the slide timer so slides don't advance while hidden
    if (slideTimer) {
      // We can't read how much time is left on a setTimeout, so we track it manually.
      // scheduleNext() always stores the interval; calculate elapsed since it was set.
      var elapsed = hiddenAt - (timerSetAt || hiddenAt);
      var interval = (presentation.intervalMs || 5000);
      timerRemainingMs = Math.max(0, interval - elapsed);
      clearTimeout(slideTimer);
      slideTimer = null;
    } else {
      timerRemainingMs = null;
    }

    // Pause current video
    var slide = canvas.querySelector(".slide[data-idx=\"" + slideIndex + "\"]");
    if (slide) {
      var vid = slide.querySelector("video");
      if (vid && !vid.paused) {
        vid.pause();
        pausedForHide = true;
      } else {
        pausedForHide = false;
      }
    }

    // Pause YouTube
    var ytPl = ytPlayers[slideIndex];
    if (ytPl) { try { ytPl.pauseVideo(); } catch(e) {} }

  } else {
    // ── Coming back to foreground ─────────────────────────────
    var item  = presentation.items[slideIndex];
    var media = item ? mediaCache[item.mediaId] : null;

    if (media && media.resource_type !== "image" && media.resource_type !== "youtube") {
      // Resume video from where it paused — no re-seek, no restart
      var slide2 = canvas.querySelector(".slide[data-idx=\"" + slideIndex + "\"]");
      if (slide2 && pausedForHide) {
        var vid2 = slide2.querySelector("video");
        if (vid2) {
          // Browser may have dropped buffer — wait for canplay before resuming
          if (vid2.readyState >= 3) {
            vid2.play().catch(function() {});
          } else {
            vid2.addEventListener("canplay", function() {
              vid2.play().catch(function() {});
            }, { once: true });
          }
        }
      }
    } else if (media && media.resource_type === "youtube") {
      var ytPl2 = ytPlayers[slideIndex];
      if (ytPl2) { try { ytPl2.playVideo(); } catch(e) {} }
    }

    pausedForHide = false;

    // Resume the slide timer with only the remaining time
    if (timerRemainingMs !== null) {
      slideTimer = setTimeout(function() {
        showSlide(presentation, (slideIndex + 1) % (presentation.items.length || 1));
      }, timerRemainingMs);
      timerRemainingMs = null;
    }
  }
});

boot();
</script>
</body>
</html>
