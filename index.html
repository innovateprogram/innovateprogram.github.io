<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Display</title>
<style>
*, *::before, *::after { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; background: #000; overflow: hidden; cursor: none; }

#preload {
  position: fixed; inset: 0; z-index: 9999;
  background: #0a0a0a;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 24px;
  transition: opacity 0.5s ease;
}
#preload.out { opacity: 0; pointer-events: none; }
#preload-logo { font-family: system-ui, sans-serif; font-size: 11px; font-weight: 700; letter-spacing: 0.2em; text-transform: uppercase; color: #444; }
#preload-title { font-family: system-ui, sans-serif; font-size: 20px; font-weight: 600; color: #fff; letter-spacing: 0.02em; }
#preload-track { width: 280px; height: 2px; background: #222; border-radius: 1px; overflow: hidden; }
#preload-fill { height: 100%; width: 0%; background: #fff; border-radius: 1px; transition: width 0.2s ease; }
#preload-status { font-family: system-ui, sans-serif; font-size: 11px; color: #444; letter-spacing: 0.05em; }

.canvas { position: fixed; inset: 0; background: #000; }
.slide { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; }
.slide.cut { transition: none !important; }
.slide.fade { transition: opacity 800ms ease; }
.slide.visible { opacity: 1; pointer-events: auto; }
.slide img { width: 100%; height: 100%; object-fit: contain; }
.slide video { width: 100%; height: 100%; object-fit: contain; }

.yt-wrap { position: absolute; inset: 0; }
.yt-wrap iframe { width: 100%; height: 100%; border: none; display: block; }

@keyframes bannerSlide { from { transform: translateX(-110%); } to { transform: translateX(0); } }
.overlay {
  position: absolute; top: 0; left: 0;
  padding: 16px 36px 16px 24px;
  border-radius: 0 0 10px 0;
  font-family: system-ui, Arial, sans-serif;
  font-size: clamp(18px, 3vw, 34px);
  font-weight: 800; letter-spacing: 0.02em; line-height: 1.3;
  z-index: 100; max-width: 75vw; word-break: break-word;
  box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
  display: none;
  animation: bannerSlide 0.5s cubic-bezier(0.22,1,0.36,1) both;
}
</style>
</head>
<body>

<div id="preload">
  <div id="preload-logo">Innovate</div>
  <div id="preload-title">Loading…</div>
  <div id="preload-track"><div id="preload-fill"></div></div>
  <div id="preload-status">Connecting</div>
</div>

<div class="canvas" id="canvas" style="opacity:0;transition:opacity 0.5s ease"></div>
<div class="overlay" id="overlay"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, onValue, get, set, update, onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const canvas = document.getElementById("canvas");
const overlayEl = document.getElementById("overlay");
const preload = document.getElementById("preload");
const preloadFill = document.getElementById("preload-fill");
const preloadStatus = document.getElementById("preload-status");
const preloadTitle = document.getElementById("preload-title");

let mediaCache = {};
let slideEls = [];
let presentation = null;
let slideIndex = 0;
let slideTimer = null;
let ytPlayers = {};
let ytApiReady = false;
let ytApiLoading = false;
let pendingYtInits = [];
let monitorName = null;
let monitorRef = null;
let lastCommandAt = 0;

// ── Preload UI ─────────────────────────────────────────────────────────────────
function setProgress(pct, label) {
  preloadFill.style.width = Math.min(100, Math.max(0, pct)) + "%";
  if (label != null) preloadStatus.textContent = label;
}
function dismissPreload() {
  preload.classList.add("out");
  canvas.style.opacity = "1";
  setTimeout(() => preload.style.display = "none", 600);
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ── Monitor identity ───────────────────────────────────────────────────────────
function getMonitorName() {
  try {
    const q = new URL(window.location.href).searchParams.get("monitor");
    if (q && q.trim()) { localStorage.setItem("monitorName", q.trim()); return q.trim(); }
  } catch(e) {}
  const ls = localStorage.getItem("monitorName");
  if (ls && ls.trim()) return ls.trim();
  const p = prompt("Enter monitor name:", "");
  if (p && p.trim()) { localStorage.setItem("monitorName", p.trim()); return p.trim(); }
  return null;
}

// ── Presence / heartbeat ───────────────────────────────────────────────────────
// IMPORTANT: use update() not set() so we never wipe the presentation assignment
async function registerPresence(name) {
  if (!name) return;
  const key = encodeURIComponent(name);
  monitorRef = ref(db, `monitors/${key}`);

  // update() merges - never overwrites fields we don't specify (like presentation)
  const presencePayload = {
    status: "online",
    lastSeen: Date.now(),
    resolution: `${screen.width}x${screen.height}`
  };
  await update(monitorRef, presencePayload).catch(() => {});
  // On disconnect, only update status/lastSeen - leave presentation intact
  onDisconnect(monitorRef).update({ status: "offline", lastSeen: Date.now() }).catch(() => {});

  setInterval(async () => {
    try { await update(monitorRef, { lastSeen: Date.now(), resolution: `${screen.width}x${screen.height}` }); } catch(e) {}
  }, 5000);
}

// ── Commands ───────────────────────────────────────────────────────────────────
function attachCommandListener(name) {
  if (!name) return;
  onValue(ref(db, `monitors/${encodeURIComponent(name)}/command`), snap => {
    const cmd = snap.val();
    if (!cmd || !cmd.at || cmd.at <= lastCommandAt) return;
    lastCommandAt = cmd.at;
    if (cmd.cmd === "reloadPresentation") handlePresentationChange(true);
  });
}

// ── Presentation resolution ────────────────────────────────────────────────────
// Priority: explicit monitor assignment > active presentation > presentations/current
async function resolvePresentation(name) {
  if (!name) return null;
  const key = encodeURIComponent(name);
  const monSnap = await get(ref(db, `monitors/${key}`));
  const monData = monSnap.val();

  // Explicit assignment?
  let pid = null;
  if (typeof monData === "string") pid = monData;
  else if (monData && typeof monData === "object") {
    pid = monData.presentation || monData.assigned || monData.pid || null;
  }

  if (pid) {
    const snap = await get(ref(db, `presentations/${pid}`));
    const p = snap.val();
    if (p && p.items && p.items.length) return p;
  }

  // Fallback: active presentation
  const activeSnap = await get(ref(db, "activePresentation"));
  const activeId = activeSnap.val();
  if (activeId) {
    const snap = await get(ref(db, `presentations/${activeId}`));
    const p = snap.val();
    if (p && p.items && p.items.length) return p;
  }

  // Fallback: presentations/current
  const curSnap = await get(ref(db, "presentations/current"));
  return curSnap.val();
}

// ── Cleanup ────────────────────────────────────────────────────────────────────
function cleanupSlides() {
  clearTimeout(slideTimer); slideTimer = null;
  canvas.querySelectorAll(".slide").forEach(s => {
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { try { v.pause(); v.onended = null; } catch(e){} }
  });
  ytPlayers = {};
  slideEls = [];
  canvas.innerHTML = "";
}

// ── Build slides ───────────────────────────────────────────────────────────────
function buildSlides(p) {
  cleanupSlides();
  if (!p || !p.items || !p.items.length) return;
  p.items.forEach((it, idx) => {
    const m = mediaCache[it.mediaId];
    const slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;
    if (!m) {
      slide.innerHTML = `<div style="color:#555;font-family:system-ui;font-size:20px">Missing media</div>`;
    } else if (m.resource_type === "youtube") {
      const wrap = document.createElement("div"); wrap.className = "yt-wrap";
      const div = document.createElement("div"); div.id = `yt-${idx}`;
      wrap.appendChild(div); slide.appendChild(wrap);
    } else if (m.resource_type === "image") {
      const img = document.createElement("img"); img.src = m.url; slide.appendChild(img);
    } else {
      const vid = document.createElement("video");
      vid.src = m.url; vid.preload = "auto"; vid.muted = true; vid.setAttribute("playsinline","");
      slide.appendChild(vid);
    }
    canvas.appendChild(slide);
    slideEls.push(slide);
  });
}

// ── Wait helpers ───────────────────────────────────────────────────────────────
function waitForVideo(vid, startTime) {
  return new Promise(resolve => {
    let done = false;
    const finish = () => { if (done) return; done = true; resolve(); };
    const timeout = setTimeout(finish, 12000);
    const checkReady = () => {
      if (vid.readyState >= 3) { clearTimeout(timeout); finish(); return; }
      vid.addEventListener("canplay", () => { clearTimeout(timeout); finish(); }, { once: true });
    };
    const seekAndWait = () => {
      if (done) return;
      const st = startTime || 0;
      try { if (st > 0 && isFinite(vid.duration) && st < vid.duration) vid.currentTime = st; } catch(e) {}
      checkReady();
    };
    if (vid.readyState >= 1) seekAndWait();
    else vid.addEventListener("loadedmetadata", seekAndWait, { once: true });
    vid.load();
  });
}
function waitForImage(img) {
  return new Promise(resolve => {
    if (img.complete && img.naturalWidth > 0) { resolve(); return; }
    img.addEventListener("load", resolve, { once: true });
    img.addEventListener("error", resolve, { once: true });
  });
}

// ── Playback ───────────────────────────────────────────────────────────────────
function showSlide(p, idx) {
  clearTimeout(slideTimer); slideTimer = null;
  if (!p || !p.items || !p.items.length) return;
  idx = ((idx % p.items.length) + p.items.length) % p.items.length;
  slideIndex = idx;

  const isCut = p.transition === "cut";
  canvas.querySelectorAll(".slide").forEach(s => {
    const i = parseInt(s.dataset.idx, 10);
    if (i === idx) return;
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { v.pause(); v.onended = null; }
    const pl = ytPlayers[i];
    if (pl) { try { pl.pauseVideo(); } catch(e){} }
  });

  const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
  if (!slide) return;
  slide.className = "slide " + (isCut ? "cut" : "fade");
  void slide.offsetWidth;
  slide.classList.add("visible");

  const item = p.items[idx];
  const media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }
  if (media.resource_type === "youtube") {
    playYT(p, idx, item, media);
  } else if (media.resource_type !== "image") {
    const vid = slide.querySelector("video");
    if (vid) playVideo(p, slide, vid, item);
    else scheduleNext(p);
  } else {
    scheduleNext(p);
  }
}

function playVideo(p, slideEl, vid, item) {
  const start = item.start || 0;
  const end = item.end || null;
  vid.onended = null;
  vid.muted = false;
  try { if (isFinite(vid.duration) && start < vid.duration) vid.currentTime = start; } catch(e){}
  vid.play().catch(() => {});
  if (end && end > start) {
    const poll = () => {
      if (!slideEl.classList.contains("visible")) return;
      if (vid.currentTime >= end) { vid.pause(); advance(p); }
      else requestAnimationFrame(poll);
    };
    requestAnimationFrame(poll);
  } else {
    vid.onended = () => advance(p);
  }
}

function scheduleNext(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (p.mode === "single") return;
  slideTimer = setTimeout(() => advance(p), p.intervalMs || 5000);
}
function advance(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (!p || p.mode === "single") return;
  showSlide(p, slideIndex + 1);
}

// ── YouTube with autoplay bypass ───────────────────────────────────────────────
// KEY FIX: We create the iframe with autoplay=1 AND mute=1 first so browsers allow
// autoplay. Then unmute after the video starts playing.
function loadYtApi(cb) {
  if (ytApiReady) { cb(); return; }
  pendingYtInits.push(cb);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = () => {
    ytApiReady = true;
    pendingYtInits.forEach(fn => fn());
    pendingYtInits = [];
  };
  const tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

function playYT(p, idx, item, media) {
  const start = (item.start != null) ? item.start : (media.start != null ? media.start : 0);
  const end = (item.end != null) ? item.end : (media.end != null ? media.end : null);

  loadYtApi(() => {
    if (ytPlayers[idx]) {
      const pl = ytPlayers[idx];
      try {
        pl.seekTo(start, true);
        pl.unMute();
        pl.setVolume(100);
        pl.playVideo();
      } catch(e){}
      if (end && end > start) pollYt(p, idx, pl, end);
      return;
    }

    const divId = `yt-${idx}`;
    if (!document.getElementById(divId)) return;

    new window.YT.Player(divId, {
      videoId: media.ytId,
      playerVars: {
        autoplay: 1,
        controls: 0,
        disablekb: 1,
        modestbranding: 1,
        rel: 0,
        start: Math.floor(start),
        // Start muted so browser autoplay policy is satisfied, then unmute
        mute: 1,
        playsinline: 1,
        enablejsapi: 1,
        // Prevent related videos showing at end
        iv_load_policy: 3,
        fs: 0
      },
      events: {
        onReady: function(e) {
          ytPlayers[idx] = e.target;
          e.target.mute();
          try { e.target.seekTo(start, true); } catch(err){}
          e.target.playVideo();
          // Unmute after brief delay (autoplay policy bypass)
          setTimeout(() => {
            try {
              e.target.unMute();
              e.target.setVolume(100);
            } catch(err) {}
          }, 500);
          if (end && end > start) pollYt(p, idx, e.target, end);
        },
        onStateChange: function(e) {
          // YT.PlayerState.ENDED = 0, PLAYING = 1
          if (e.data === 0) advance(p);
          if (e.data === 1) {
            // Playing - ensure unmuted
            setTimeout(() => {
              try { e.target.unMute(); e.target.setVolume(100); } catch(err){}
            }, 300);
          }
        },
        onError: function(e) {
          console.warn("YT player error:", e.data);
          advance(p);
        }
      }
    });
  });
}

function pollYt(p, idx, player, end) {
  const check = () => {
    const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
    if (!slide || !slide.classList.contains("visible")) return;
    try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advance(p); return; } } catch(e){}
    requestAnimationFrame(check);
  };
  requestAnimationFrame(check);
}

// ── Overlay ────────────────────────────────────────────────────────────────────
let overlayVisible = false;
function applyOverlay(p, animate) {
  const ov = p.overlay || {};
  if (ov.visible && ov.text) {
    overlayEl.style.background = ov.color || "#cc0000";
    overlayEl.style.color = ov.textColor || "#fff";
    overlayEl.textContent = ov.text;
    overlayEl.style.display = "block";
    if (animate && !overlayVisible) {
      overlayEl.style.animation = "none";
      void overlayEl.offsetWidth;
      overlayEl.style.animation = "";
    }
    overlayVisible = true;
  } else {
    overlayEl.style.display = "none";
    overlayVisible = false;
  }
}

// ── Presentation change / reload ───────────────────────────────────────────────
let currentPresentationKey = null; // used to detect actual changes

async function handlePresentationChange(forceReload) {
  const p = await resolvePresentation(monitorName);

  if (!p || !p.items || !p.items.length) {
    setProgress(100, "No slides found");
    await sleep(600);
    dismissPreload();
    return;
  }

  // Compute a fingerprint to avoid unnecessary rebuilds
  const fp = JSON.stringify(p.items.map(i => i.mediaId)) + p.name + p.intervalMs + p.transition;
  if (!forceReload && fp === currentPresentationKey) {
    // Just update overlay
    presentation = p;
    applyOverlay(p, true);
    return;
  }
  currentPresentationKey = fp;

  setProgress(5, "Fetching media…");
  const mediaSnap = await get(ref(db, "media"));
  mediaCache = mediaSnap.val() || {};

  presentation = p;
  buildSlides(p);

  // Preload
  let loaded = 0;
  const total = p.items.length;
  const promises = p.items.map((it, idx) => {
    const m = mediaCache[it.mediaId];
    if (!m || m.resource_type === "youtube") {
      return Promise.resolve().then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    }
    const slide = slideEls[idx];
    if (m.resource_type === "image") {
      const img = slide.querySelector("img");
      return waitForImage(img).then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    } else {
      const vid = slide.querySelector("video");
      return waitForVideo(vid, it.start || 0).then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    }
  });

  await Promise.all(promises);
  setProgress(100, "Ready");
  await sleep(200);
  dismissPreload();
  applyOverlay(p, true);
  slideIndex = 0;
  showSlide(p, 0);
}

// ── Live update listeners ──────────────────────────────────────────────────────
// CRITICAL: onValue fires immediately with the current value on attach.
// We must ignore that first fire to avoid reload loops and spurious rebuilds.
// We also debounce all handlers so rapid sequential changes only trigger one reload.

let changeDebounceTimer = null;
function debouncedPresentationChange(force) {
  clearTimeout(changeDebounceTimer);
  changeDebounceTimer = setTimeout(() => handlePresentationChange(force), 300);
}

function attachListeners() {
  // ── Monitor assignment listener ────────────────────────────────────────────
  // Fires when this monitor's own record changes (assignment, commands, etc.)
  // Skip the first fire (initial value on attach) to avoid double-loading on boot.
  let monitorFirstFire = true;
  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), () => {
    if (monitorFirstFire) { monitorFirstFire = false; return; }
    debouncedPresentationChange(false);
  });

  // ── Active presentation changed ────────────────────────────────────────────
  // Only react if this monitor has NO explicit assignment (fallback mode).
  let activeFirstFire = true;
  onValue(ref(db, "activePresentation"), async () => {
    if (activeFirstFire) { activeFirstFire = false; return; }
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;
    if (!pid) debouncedPresentationChange(false);
  });

  // ── Assigned presentation content changed ─────────────────────────────────
  // Watch the specific presentation this monitor is assigned to for live updates
  // (overlay text, slide changes, etc.) without rebuilding if nothing significant changed.
  let assignedPid = null;
  let assignedPresentationUnsub = null;
  async function watchAssignedPresentation() {
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;

    if (pid === assignedPid) return; // same presentation, no need to re-attach
    assignedPid = pid;

    // Detach previous listener if any
    if (assignedPresentationUnsub) { assignedPresentationUnsub(); assignedPresentationUnsub = null; }

    if (!pid) return; // no explicit assignment, handled by activePresentation listener

    let presentationFirstFire = true;
    assignedPresentationUnsub = onValue(ref(db, `presentations/${pid}`), () => {
      if (presentationFirstFire) { presentationFirstFire = false; return; }
      debouncedPresentationChange(false);
    });
  }

  // Re-evaluate which presentation to watch whenever monitor record changes
  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), watchAssignedPresentation);

  // Fallback: presentations/current for unmapped monitors
  let curFirstFire = true;
  onValue(ref(db, "presentations/current"), async () => {
    if (curFirstFire) { curFirstFire = false; return; }
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;
    if (!pid) debouncedPresentationChange(false);
  });

  // ── Global hard-refresh signal ─────────────────────────────────────────────
  // CRITICAL FIX: Record the signal value at boot time.
  // Only reload if the signal CHANGES after we've loaded - not on the initial value.
  let lastRefreshSignal = null;
  onValue(ref(db, "refreshSignal"), snap => {
    const val = snap.val();
    if (lastRefreshSignal === null) {
      // First fire - just record current value, don't reload
      lastRefreshSignal = val;
      return;
    }
    if (val !== lastRefreshSignal) {
      lastRefreshSignal = val;
      window.location.reload();
    }
  });
}

// ── Visibility pause/resume ────────────────────────────────────────────────────
let pausedForHide = false, timerRemaining = null, timerSetAt = null;
document.addEventListener("visibilitychange", () => {
  if (!presentation) return;
  if (document.visibilityState === "hidden") {
    if (slideTimer) {
      const now = Date.now();
      timerRemaining = Math.max(0, (presentation.intervalMs||5000) - (now - (timerSetAt||now)));
      clearTimeout(slideTimer); slideTimer = null;
    } else timerRemaining = null;
    const slide = canvas.querySelector(`.slide[data-idx="${slideIndex}"]`);
    if (slide) {
      const vid = slide.querySelector("video");
      if (vid && !vid.paused) { vid.pause(); pausedForHide = true; } else pausedForHide = false;
    }
    const ytPl = ytPlayers[slideIndex];
    if (ytPl) { try { ytPl.pauseVideo(); } catch(e){} }
  } else {
    if (pausedForHide) {
      const slide = canvas.querySelector(`.slide[data-idx="${slideIndex}"]`);
      if (slide) { const vid = slide.querySelector("video"); if (vid) vid.play().catch(()=>{}); }
    }
    const ytPl = ytPlayers[slideIndex];
    if (ytPl) { try { ytPl.playVideo(); } catch(e){} }
    pausedForHide = false;
    if (timerRemaining !== null) {
      slideTimer = setTimeout(() => advance(presentation), timerRemaining);
      timerRemaining = null;
    }
  }
});

// ── Boot ───────────────────────────────────────────────────────────────────────
async function boot() {
  setProgress(0, "Connecting…");
  monitorName = getMonitorName();
  if (monitorName) preloadTitle.textContent = monitorName;
  await registerPresence(monitorName);
  attachCommandListener(monitorName);
  attachListeners();
  await handlePresentationChange(false);
}

boot();
</script>
</body>
</html>
