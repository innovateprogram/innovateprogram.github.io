<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fullscreen View</title>
<style>
  html, body { height: 100%; margin: 0; padding: 0; background: #000; color: #fff; font-family: system-ui, Arial; cursor: none; overflow: hidden; }
  .canvas { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; }

  .slide { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; transition: opacity 800ms ease; opacity: 0; pointer-events: none; }
  .slide.visible { opacity: 1; pointer-events: auto; }
  .slide img, .slide video { max-width: 100%; max-height: 100%; object-fit: contain; }

  /* YouTube iframe fills the slide */
  .yt-container { position: absolute; inset: 0; }
  .yt-container iframe { width: 100%; height: 100%; border: none; display: block; }

  /* Top-left banner overlay */
  @keyframes bannerIn {
    from { transform: translateX(-110%); }
    to   { transform: translateX(0); }
  }
  .overlay {
    position: absolute; top: 0; left: 0;
    padding: 18px 40px 18px 28px;
    border-radius: 0 0 12px 0;
    font-size: 28px; font-weight: 800; letter-spacing: 0.03em; line-height: 1.3;
    z-index: 100; max-width: 80vw; word-break: break-word;
    box-shadow: 6px 6px 0 rgba(0,0,0,0.35);
    animation: bannerIn 0.55s cubic-bezier(0.22, 1, 0.36, 1) both;
  }
</style>
</head>
<body>
<div class="canvas" id="canvas"></div>
<div class="overlay" id="overlay" style="display:none"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, onValue, get } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const mediaRef = ref(db, "media");
const activeRef = ref(db, "activePresentation");
const presentationsRef = ref(db, "presentations");
const refreshRef = ref(db, "refreshSignal");

// Hard-reload when the editor sends a refresh signal.
// Skip the first emission (initial value on page load) so we don't reload immediately.
let refreshInitialSkipped = false;
onValue(refreshRef, () => {
  if (!refreshInitialSkipped) { refreshInitialSkipped = true; return; }
  location.reload(true);
});

const canvas = document.getElementById("canvas");
const overlayEl = document.getElementById("overlay");

let mediaCache = {};
let presentation = null;
let slideIndex = 0;
let slideTimer = null;
let currentSlideEl = null;
let ytPlayers = {}; // map of slide index -> YT.Player instance
let ytApiReady = false;
let ytApiLoading = false;
let pendingYtInits = []; // queued until API ready

// Only loads the YouTube IFrame API script the first time a YT video is needed
function loadYtApiIfNeeded(callback) {
  if (ytApiReady) { callback(); return; }
  pendingYtInits.push(callback);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = () => {
    ytApiReady = true;
    pendingYtInits.forEach(fn => fn());
    pendingYtInits = [];
  };
  const tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

onValue(mediaRef, snap => {
  mediaCache = snap.val() || {};
  if (presentation) renderPresentation(presentation);
});

// Listen for which presentation is active
onValue(activeRef, async snap => {
  const activeId = snap.val();
  if (activeId) {
    const pSnap = await get(ref(db, `presentations/${activeId}`));
    const p = pSnap.val();
    if (p) { presentation = p; renderPresentation(p); return; }
  }
  // Fallback to legacy "current"
  const curSnap = await get(ref(db, "presentations/current"));
  if (curSnap.val()) { presentation = curSnap.val(); renderPresentation(presentation); }
});

// Also watch the presentations/current for real-time overlay/settings changes
onValue(ref(db, "presentations/current"), snap => {
  // Only use this if no activeRef is set
});

function destroyYtPlayers() {
  Object.values(ytPlayers).forEach(player => {
    try { player.destroy(); } catch(e) {}
  });
  ytPlayers = {};
}

function renderPresentation(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  slideIndex = 0;

  canvas.querySelectorAll("video").forEach(v => v.pause());
  destroyYtPlayers();
  canvas.innerHTML = "";

  if (!p || !p.items || p.items.length === 0) {
    overlayEl.style.display = "none";
    return;
  }

  // Overlay
  const overlayColor = (p.overlay && p.overlay.color) || "#cc0000";
  const overlayTextColor = (p.overlay && p.overlay.textColor) || "#ffffff";
  overlayEl.style.background = overlayColor;
  overlayEl.style.color = overlayTextColor;
  overlayEl.textContent = (p.overlay && p.overlay.text) || "";
  const overlayVisible = p.overlay && p.overlay.visible;
  if (overlayVisible) {
    overlayEl.style.display = "block";
    overlayEl.style.animation = "none";
    void overlayEl.offsetWidth;
    overlayEl.style.animation = "";
  } else {
    overlayEl.style.display = "none";
  }

  // Build slides
  p.items.forEach((it, idx) => {
    const m = mediaCache[it.mediaId];
    const slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;

    if (!m) {
      slide.innerHTML = `<div style="color:#fff;font-size:24px">Missing media: ${it.mediaId}</div>`;
    } else if (m.resource_type === "youtube") {
      // Create a div placeholder for the YT player
      const ytWrap = document.createElement("div");
      ytWrap.className = "yt-container";
      const ytDiv = document.createElement("div");
      ytDiv.id = `yt-player-${idx}`;
      ytWrap.appendChild(ytDiv);
      slide.appendChild(ytWrap);
    } else if (m.resource_type === "image") {
      const img = document.createElement("img");
      img.src = m.url;
      slide.appendChild(img);
    } else {
      const vid = document.createElement("video");
      vid.src = m.url;
      vid.setAttribute("playsinline", "");
      vid.preload = "auto";
      vid.controls = false;
      vid.style.maxWidth = "100%";
      vid.style.maxHeight = "100%";
      slide.appendChild(vid);
    }
    canvas.appendChild(slide);
  });

  slideIndex = 0;
  showSlideAtIndex(p, 0);
}

function showSlideAtIndex(p, idx) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (!p.items || p.items.length === 0) return;
  if (idx >= p.items.length) idx = 0;
  if (idx < 0) idx = 0;
  slideIndex = idx;

  const slides = Array.from(canvas.querySelectorAll(".slide"));

  // Hide all others, pause their media
  slides.forEach(s => {
    const i = parseInt(s.dataset.idx, 10);
    if (i !== idx) {
      s.classList.remove("visible");
      const v = s.querySelector("video");
      if (v) { v.pause(); v.onended = null; }
      const ytPlayer = ytPlayers[i];
      if (ytPlayer) { try { ytPlayer.pauseVideo(); } catch(e){} }
    }
  });

  const newSlide = slides.find(s => parseInt(s.dataset.idx, 10) === idx);
  if (!newSlide) return;

  if (p.transition === "cut") {
    newSlide.style.transition = "none";
  } else {
    newSlide.style.transition = "opacity 800ms ease";
  }
  void newSlide.offsetWidth;
  newSlide.classList.add("visible");
  currentSlideEl = newSlide;

  const item = p.items[idx];
  const media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }

  if (media.resource_type === "youtube") {
    playYouTubeSlide(p, idx, item, media);
  } else {
    const videoEl = newSlide.querySelector("video");
    if (videoEl) {
      playVideoSlide(p, newSlide, videoEl, item);
    } else {
      scheduleNext(p); // image
    }
  }
}

function playVideoSlide(p, slideEl, videoEl, item) {
  const start = item.start || 0;
  const end = item.end || null;
  videoEl.onended = null;
  videoEl.onloadedmetadata = null;

  const playFrom = () => {
    try {
      if (videoEl.duration && start <= videoEl.duration) {
        videoEl.currentTime = Math.min(start, videoEl.duration - 0.01);
      }
    } catch(e) {}
    videoEl.play().catch(() => {});
    if (end && end > start) {
      const checkEnd = () => {
        if (!slideEl.classList.contains("visible")) return;
        if (videoEl.currentTime >= end) { videoEl.pause(); advanceNow(p); }
        else requestAnimationFrame(checkEnd);
      };
      requestAnimationFrame(checkEnd);
    } else {
      videoEl.onended = () => advanceNow(p);
    }
  };
  if (videoEl.readyState >= 1) playFrom();
  else { videoEl.onloadedmetadata = () => playFrom(); videoEl.load(); }
}

function playYouTubeSlide(p, idx, item, media) {
  const start = item.start != null ? item.start : (media.start || 0);
  const end = item.end != null ? item.end : (media.end || null);
  const ytId = media.ytId;

  const onPlayerReady = (player) => {
    ytPlayers[idx] = player;
    try { player.seekTo(start, true); } catch(e) {}
    player.playVideo();

    if (end && end > start) {
      const checkEnd = () => {
        const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
        if (!slide || !slide.classList.contains("visible")) return;
        try {
          const t = player.getCurrentTime();
          if (t >= end) { player.pauseVideo(); advanceNow(p); return; }
        } catch(e) {}
        requestAnimationFrame(checkEnd);
      };
      requestAnimationFrame(checkEnd);
    }
  };

  const onStateChange = (event, player) => {
    // YT.PlayerState.ENDED = 0
    if (event.data === 0) {
      advanceNow(p);
    }
  };

  const init = () => {
    // If player already exists, reuse it
    if (ytPlayers[idx]) {
      const player = ytPlayers[idx];
      try {
        player.seekTo(start, true);
        player.playVideo();
        if (end && end > start) {
          const checkEnd = () => {
            const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
            if (!slide || !slide.classList.contains("visible")) return;
            try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advanceNow(p); return; } } catch(e) {}
            requestAnimationFrame(checkEnd);
          };
          requestAnimationFrame(checkEnd);
        }
      } catch(e) {}
      return;
    }

    const divId = `yt-player-${idx}`;
    if (!document.getElementById(divId)) return;

    new window.YT.Player(divId, {
      videoId: ytId,
      playerVars: {
        autoplay: 1,
        controls: 0,
        disablekb: 1,
        modestbranding: 1,
        rel: 0,
        start: Math.floor(start),
        mute: 0,
        playsinline: 1,
        enablejsapi: 1
      },
      events: {
        onReady: (e) => onPlayerReady(e.target),
        onStateChange: (e) => onStateChange(e, e.target)
      }
    });
  };

  loadYtApiIfNeeded(init);
}

function advanceNow(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  const next = (slideIndex + 1) % (p.items.length || 1);
  showSlideAtIndex(p, next);
}

function scheduleNext(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  const interval = p.intervalMs || 5000;
  slideTimer = setTimeout(() => {
    const next = (slideIndex + 1) % (p.items.length || 1);
    showSlideAtIndex(p, next);
  }, interval);
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && presentation) {
    showSlideAtIndex(presentation, slideIndex);
  }
});
</script>
</body>
</html>
