<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fullscreen View</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; padding: 0; background: #000; color: #fff; font-family: system-ui, Arial; cursor: none; overflow: hidden; }

  #preloadScreen {
    position: fixed; inset: 0; z-index: 9999;
    background: #0a0a0a;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 28px;
    transition: opacity 0.6s ease;
  }
  #preloadScreen.fade-out { opacity: 0; pointer-events: none; }
  #preloadLogo  { font-size: 15px; font-weight: 700; letter-spacing: 0.18em; text-transform: uppercase; color: #555; }
  #preloadTitle { font-size: 22px; font-weight: 700; letter-spacing: 0.04em; color: #fff; }
  #preloadBarWrap  { width: 320px; max-width: 80vw; }
  #preloadBarTrack { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; }
  #preloadBarFill  { height: 100%; width: 0%; background: #fff; border-radius: 3px; transition: width 0.25s ease; }
  #preloadStatus   { margin-top: 10px; font-size: 12px; color: #555; letter-spacing: 0.05em; text-align: center; min-height: 18px; }

  .canvas { position: fixed; inset: 0; background: #000; }
  .slide  { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 800ms ease; }
  .slide.visible { opacity: 1; pointer-events: auto; }
  .slide img   { max-width: 100%; max-height: 100%; object-fit: contain; }
  .slide video { max-width: 100%; max-height: 100%; object-fit: contain; }

  .yt-container { position: absolute; inset: 0; }
  .yt-container iframe { width: 100%; height: 100%; border: none; display: block; }

  @keyframes bannerIn {
    from { transform: translateX(-110%); }
    to   { transform: translateX(0); }
  }
  .overlay {
    position: absolute; top: 0; left: 0;
    padding: 18px 40px 18px 28px;
    border-radius: 0 0 12px 0;
    font-size: 28px; font-weight: 800; letter-spacing: 0.03em; line-height: 1.3;
    z-index: 100; max-width: 80vw; word-break: break-word;
    box-shadow: 6px 6px 0 rgba(0,0,0,0.35);
    display: none;
  }
  .overlay.animate-in { animation: bannerIn 0.55s cubic-bezier(0.22, 1, 0.36, 1) both; }
</style>
</head>
<body>

<div id="preloadScreen">
  <div id="preloadLogo">Innovate</div>
  <div id="preloadTitle">Loading Elements</div>
  <div id="preloadBarWrap">
    <div id="preloadBarTrack"><div id="preloadBarFill"></div></div>
    <div id="preloadStatus">Connecting…</div>
  </div>
</div>

<div class="canvas" id="canvas" style="opacity:0;transition:opacity 0.6s ease"></div>
<div class="overlay" id="overlay"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, onValue, get, set, update, onDisconnect
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const canvas        = document.getElementById("canvas");
const overlayEl     = document.getElementById("overlay");
const preloadScreen = document.getElementById("preloadScreen");
const preloadFill   = document.getElementById("preloadBarFill");
const preloadStatus = document.getElementById("preloadStatus");

let mediaCache     = {};
let slideEls       = [];
let presentation   = null;
let slideIndex     = 0;
let slideTimer     = null;
let ytPlayers      = {};
let ytApiReady     = false;
let ytApiLoading   = false;
let pendingYtInits = [];
let overlayShown   = false;

let monitorName = null;
let monitorRef = null;
let heartbeatInterval = null;
let lastCommandAt = 0;

// ── Utilities ─────────────────────────────────────────────────
function setProgress(pct, label) {
  preloadFill.style.width = Math.min(100, Math.max(0, pct)) + "%";
  if (label !== undefined) preloadStatus.textContent = label;
}
function dismissPreload() {
  preloadScreen.classList.add("fade-out");
  canvas.style.opacity = "1";
  setTimeout(function() { preloadScreen.style.display = "none"; }, 650);
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
function escHtml(s){ return s?String(s).replaceAll("<","&lt;").replaceAll(">","&gt;"):""; }

// ── Monitor identity (persisted) ──────────────────────────────
function getPersistedMonitorName() {
  // 1) URL param ?monitor=Name
  try {
    const url = new URL(window.location.href);
    const q = url.searchParams.get("monitor");
    if (q && q.trim()) { localStorage.setItem("monitorName", q.trim()); return q.trim(); }
  } catch(e){}
  // 2) localStorage
  const ls = localStorage.getItem("monitorName");
  if (ls && ls.trim()) return ls.trim();
  // 3) prompt once
  const p = prompt("Enter monitor name (exact):", "");
  if (p && p.trim()) { localStorage.setItem("monitorName", p.trim()); return p.trim(); }
  return null;
}

// ── Presence / Heartbeat ──────────────────────────────────────
async function registerPresence(name) {
  if (!name) return;
  const key = encodeURIComponent(name);
  monitorRef = ref(db, `monitors/${key}`);

  const payload = {
    status: "online",
    lastSeen: Date.now(),
    resolution: `${screen.width}x${screen.height}`
  };
  await set(monitorRef, payload).catch(()=>{});
  // onDisconnect: mark offline
  const od = onDisconnect(monitorRef);
  od.update({ status: "offline", lastSeen: Date.now() }).catch(()=>{});

  // heartbeat
  if (heartbeatInterval) clearInterval(heartbeatInterval);
  heartbeatInterval = setInterval(async () => {
    try { await update(monitorRef, { lastSeen: Date.now(), resolution: `${screen.width}x${screen.height}` }); } catch(e) {}
  }, 5000);
}

// ── Command listener (per-monitor) ────────────────────────────
// Commands are written by dashboard to: monitors/<name>/command
function attachCommandListener(name) {
  if (!name) return;
  const key = encodeURIComponent(name);
  const cmdRef = ref(db, `monitors/${key}/command`);
  onValue(cmdRef, snap => {
    const cmd = snap.val();
    if (!cmd || !cmd.at) return;
    if (cmd.at <= lastCommandAt) return;
    lastCommandAt = cmd.at;
    if (cmd.cmd === "reloadPresentation") {
      // explicit reload (re-fetch mapping & presentation)
      handlePresentationChange(true);
    } else if (cmd.cmd === "refreshMediaCache") {
      // quick re-fetch of media list
      fetchMediaAndMaybeRefreshPresentation();
    }
    // clear command if desired (optional) -- leaving it so dashboard can show history
  });
}

// ── Load helpers ──────────────────────────────────────────────
async function fetchMediaAndMaybeRefreshPresentation() {
  setProgress(1, "Fetching media…");
  const mediaSnap = await get(ref(db, "media"));
  mediaCache = mediaSnap.val() || {};
  setProgress(2, "Media loaded");
  // if presentation already loaded: try to refresh content in-place
  if (presentation) {
    // rebuild slides with new mediaCache but attempt to preserve current slide index/time
    await buildSlides(presentation);
  }
}

async function loadPresentationById(pId) {
  if (!pId) return null;
  const snap = await get(ref(db, `presentations/${pId}`));
  return snap.val();
}

async function loadFallbackPresentation() {
  const activeSnap = await get(ref(db, "activePresentation"));
  const activeId = activeSnap.val();
  if (activeId) {
    const s1 = await get(ref(db, `presentations/${activeId}`));
    if (s1 && s1.val()) return s1.val();
  }
  const cur = await get(ref(db, "presentations/current"));
  return cur.val();
}

// ── Clean up before switching presentations ────────────────────
function cleanupCurrentPresentation() {
  // stop timers
  clearTimeout(slideTimer);
  slideTimer = null;
  // pause videos and remove slides
  const slides = Array.from(canvas.querySelectorAll(".slide"));
  slides.forEach(s => {
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { try { v.pause(); v.onended = null; } catch(e){} }
  });
  // destroy YouTube players map (they may persist in iframe API but we'll drop refs)
  ytPlayers = {};
  slideEls = [];
  canvas.innerHTML = "";
}

// ── Build slides (create DOM for presentation) ────────────────
async function buildSlides(p) {
  cleanupCurrentPresentation();
  if (!p || !p.items || !p.items.length) return;
  // create slides
  canvas.innerHTML = "";
  slideEls = [];
  p.items.forEach((it, idx) => {
    const m = mediaCache[it.mediaId];
    const slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;
    if (!m) {
      slide.innerHTML = `<div style='color:#fff;font-size:24px'>Missing: ${escHtml(it.mediaId)}</div>`;
    } else if (m.resource_type === "youtube") {
      const wrap = document.createElement("div"); wrap.className = "yt-container";
      const div = document.createElement("div"); div.id = `yt-player-${idx}`;
      wrap.appendChild(div);
      slide.appendChild(wrap);
    } else if (m.resource_type === "image") {
      const img = document.createElement("img"); img.src = m.url; slide.appendChild(img);
    } else {
      const vid = document.createElement("video");
      vid.src = m.url;
      vid.preload = "auto";
      vid.muted = true;
      vid.setAttribute("playsinline", "");
      vid.controls = false;
      slide.appendChild(vid);
    }
    canvas.appendChild(slide);
    slideEls.push(slide);
  });
}

// ── Preload / wait for readiness ──────────────────────────────
function waitForVideoReady(vid, startTime) {
  return new Promise(resolve => {
    const st = startTime || 0;
    let done = false;
    const finish = () => { if (done) return; done = true; resolve(); };
    const timeout = setTimeout(finish, 12000);
    const checkReady = () => {
      if (vid.readyState >= 3) { clearTimeout(timeout); finish(); return; }
      vid.addEventListener("canplay", () => { clearTimeout(timeout); finish(); }, { once: true });
    };
    const seekAndWait = () => {
      if (done) return;
      try { if (st > 0 && isFinite(vid.duration) && st < vid.duration) vid.currentTime = st; } catch(e) {}
      checkReady();
    };
    if (vid.readyState >= 1) seekAndWait();
    else vid.addEventListener("loadedmetadata", seekAndWait, { once: true });
    vid.load();
  });
}
function waitForImageReady(img) {
  return new Promise(resolve => {
    if (img.complete && img.naturalWidth > 0) { resolve(); return; }
    img.addEventListener("load", resolve, { once: true });
    img.addEventListener("error", resolve, { once: true });
  });
}

// ── Show / schedule slides ───────────────────────────────────
function showSlide(p, idx) {
  clearTimeout(slideTimer); slideTimer = null;
  if (!p || !p.items || !p.items.length) return;
  idx = ((idx % p.items.length) + p.items.length) % p.items.length;
  slideIndex = idx;
  const slides = Array.from(canvas.querySelectorAll(".slide"));
  slides.forEach(s => {
    const i = parseInt(s.dataset.idx, 10);
    if (i === idx) return;
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { v.pause(); v.onended = null; }
    const pl = ytPlayers[i];
    if (pl) { try { pl.pauseVideo(); } catch(e) {} }
  });
  const slide = slides.find(s => parseInt(s.dataset.idx, 10) === idx);
  if (!slide) return;
  slide.style.transition = p.transition === "cut" ? "none" : "opacity 800ms ease";
  void slide.offsetWidth;
  slide.classList.add("visible");
  const item = p.items[idx];
  const media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }
  if (media.resource_type === "youtube") {
    playYT(p, idx, item, media);
  } else if (media.resource_type !== "image") {
    const vid = slide.querySelector("video");
    if (vid) playVideo(p, slide, vid, item);
    else scheduleNext(p);
  } else {
    scheduleNext(p);
  }
}

function playVideo(p, slideEl, vid, item) {
  const start = item.start || 0;
  const end = item.end || null;
  vid.onended = null;
  vid.onloadedmetadata = null;
  vid.muted = false;
  try { if (isFinite(vid.duration) && start < vid.duration) vid.currentTime = Math.min(start, vid.duration - 0.01); } catch(e){}
  vid.play().catch(()=>{});
  if (end && end > start) {
    const poll = () => {
      if (!slideEl.classList.contains("visible")) return;
      if (vid.currentTime >= end) { vid.pause(); advance(p); }
      else requestAnimationFrame(poll);
    };
    requestAnimationFrame(poll);
  } else {
    vid.onended = function() { advance(p); };
  }
}

function scheduleNext(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (p.mode === "single") return;
  const interval = p.intervalMs || 5000;
  slideTimer = setTimeout(() => {
    showSlide(p, (slideIndex + 1) % (p.items.length || 1));
  }, interval);
}

function advance(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (p.mode === "single") return;
  showSlide(p, (slideIndex + 1) % (p.items.length || 1));
}

// ── YouTube (iframe API) ────────────────────────────────────
function loadYtApi(cb) {
  if (ytApiReady) { cb(); return; }
  pendingYtInits.push(cb);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = function() {
    ytApiReady = true;
    pendingYtInits.forEach(fn => fn());
    pendingYtInits = [];
  };
  const tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}
function playYT(p, idx, item, media) {
  const start = (item.start != null) ? item.start : ((media.start != null) ? media.start : 0);
  const end = (item.end != null) ? item.end : ((media.end != null) ? media.end : null);
  const init = function() {
    if (ytPlayers[idx]) {
      const pl = ytPlayers[idx];
      try { pl.seekTo(start, true); pl.playVideo(); } catch(e) {}
      if (end && end > start) pollYt(p, idx, pl, end);
      return;
    }
    const divId = `yt-player-${idx}`;
    if (!document.getElementById(divId)) return;
    new window.YT.Player(divId, {
      videoId: media.ytId,
      playerVars: { autoplay:1, controls:0, disablekb:1, modestbranding:1, rel:0, start: Math.floor(start), mute:0, playsinline:1, enablejsapi:1 },
      events: {
        onReady: function(e) {
          ytPlayers[idx] = e.target;
          try { e.target.seekTo(start, true); } catch(err) {}
          e.target.playVideo();
          if (end && end > start) pollYt(p, idx, e.target, end);
        },
        onStateChange: function(e) { if (e.data === 0) advance(p); }
      }
    });
  };
  loadYtApi(init);
}
function pollYt(p, idx, player, end) {
  const check = () => {
    const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
    if (!slide || !slide.classList.contains("visible")) return;
    try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advance(p); return; } } catch(e){}
    requestAnimationFrame(check);
  };
  requestAnimationFrame(check);
}

// ── Visibility handling ──────────────────────────────────────
var pausedForHide = false;
var timerRemainingMs = null;
var timerSetAt = null;
document.addEventListener("visibilitychange", function() {
  if (!presentation) return;
  if (document.visibilityState === "hidden") {
    if (slideTimer) {
      const hiddenAt = Date.now();
      const elapsed = hiddenAt - (timerSetAt || hiddenAt);
      const interval = presentation.intervalMs || 5000;
      timerRemainingMs = Math.max(0, interval - elapsed);
      clearTimeout(slideTimer); slideTimer = null;
    } else timerRemainingMs = null;
    const slide = canvas.querySelector(`.slide[data-idx="${slideIndex}"]`);
    if (slide) {
      const vid = slide.querySelector("video");
      if (vid && !vid.paused) { vid.pause(); pausedForHide = true; } else pausedForHide = false;
    }
    const ytPl = ytPlayers[slideIndex]; if (ytPl) { try { ytPl.pauseVideo(); } catch(e){} }
  } else {
    const item = presentation.items[slideIndex];
    const media = item ? mediaCache[item.mediaId] : null;
    if (media && media.resource_type !== "image" && media.resource_type !== "youtube") {
      const slide2 = canvas.querySelector(`.slide[data-idx="${slideIndex}"]`);
      if (slide2 && pausedForHide) {
        const vid2 = slide2.querySelector("video");
        if (vid2) {
          if (vid2.readyState >= 3) vid2.play().catch(()=>{});
          else vid2.addEventListener("canplay", () => vid2.play().catch(()=>{}), { once: true });
        }
      }
    } else if (media && media.resource_type === "youtube") {
      const ytPl2 = ytPlayers[slideIndex];
      if (ytPl2) { try { ytPl2.playVideo(); } catch(e){} }
    }
    pausedForHide = false;
    if (timerRemainingMs !== null) {
      slideTimer = setTimeout(() => { showSlide(presentation, (slideIndex + 1) % (presentation.items.length || 1)); }, timerRemainingMs);
      timerRemainingMs = null;
    }
  }
});

// ── Presentation change handling (when monitors/<name> mapping or global active/current changes) ─────────────────
async function handlePresentationChange(forceReload = false) {
  // Decide which presentation to show for this monitorName:
  if (!monitorName) return;
  const mapping = (await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`))).val();
  let p = null;
  if (mapping && typeof mapping === "string") {
    // mapping is a presentationId
    p = await loadPresentationById(mapping);
  } else if (mapping && mapping.presentationId) {
    p = await loadPresentationById(mapping.presentationId);
  }

  if (!p || !p.items || !p.items.length) {
    // fallback to active/current unless explicit mapping that points to nothing
    p = await loadFallbackPresentation();
  }

  if (!p || !p.items || !p.items.length) {
    setProgress(100, "No presentation found.");
    await sleep(600);
    dismissPreload();
    return;
  }

  // If presentation hasn't changed and not forced, do nothing
  const oldIds = (presentation && presentation.items ? presentation.items.map(i=>i.mediaId).join(",") : "");
  const newIds = (p.items ? p.items.map(i=>i.mediaId).join(",") : "");
  if (!forceReload && presentation && oldIds === newIds && presentation.name === p.name && presentation.intervalMs === p.intervalMs) {
    // Only update overlay and return
    presentation = p;
    applyOverlay(p, false);
    return;
  }

  // Full in-place switch: prefetch media, build slides, preload, then start
  setProgress(0, "Preparing presentation…");

  // Fetch media cache fresh
  const mediaSnap = await get(ref(db, "media"));
  mediaCache = mediaSnap.val() || {};

  presentation = p;
  await buildSlides(p);

  // Preload assets (images & video readiness)
  let ready = 0;
  const total = p.items.length;
  setProgress(2, `Loading 0 / ${total}`);
  const preloadPromises = p.items.map((it, idx) => {
    const m = mediaCache[it.mediaId];
    if (!m || m.resource_type === "youtube") return Promise.resolve().then(()=>{ ready++; setProgress((ready/total)*95, `Loading ${ready} / ${total}`); });
    const slide = slideEls[idx];
    if (m.resource_type === "image") {
      const img = slide.querySelector("img");
      return waitForImageReady(img).then(()=>{ ready++; setProgress((ready/total)*95, `Loading ${ready} / ${total}`); });
    } else {
      const vid = slide.querySelector("video");
      const startTime = it.start || 0;
      return waitForVideoReady(vid, startTime).then(()=>{ ready++; setProgress((ready/total)*95, `Buffering ${ready} / ${total}`); });
    }
  });

  await Promise.all(preloadPromises);
  setProgress(100, "Ready — launching…");
  await sleep(250);
  dismissPreload();
  applyOverlay(p, true);

  // Start playback from first slide
  slideIndex = 0;
  showSlide(p, 0);
}

// ── Overlay ───────────────────────────────────────────────────
function applyOverlay(p, firstShow) {
  const ov = p.overlay || {};
  overlayEl.style.background = ov.color || "#cc0000";
  overlayEl.style.color = ov.textColor || "#ffffff";
  overlayEl.textContent = ov.text || (monitorName ? `Monitor: ${monitorName}` : "");
  if (ov.visible || !ov.text) {
    overlayEl.style.display = "block";
    if (firstShow && !overlayShown) {
      overlayEl.classList.remove("animate-in");
      void overlayEl.offsetWidth;
      overlayEl.classList.add("animate-in");
      overlayShown = true;
    }
  } else {
    overlayEl.style.display = "none";
    overlayShown = false;
  }
}

// ── Listeners for global changes that should trigger a re-evaluate ─────────────────
function attachGlobalListeners() {
  // If presentations/current changes and this monitor isn't explicitly mapped, update
  onValue(ref(db, "presentations/current"), async () => {
    // only act if monitor has no explicit mapping
    const mapping = (await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`))).val();
    if (mapping && (typeof mapping === "string" || mapping.presentationId)) return;
    handlePresentationChange(false);
  });

  // If activePresentation changes and monitor not mapped, update
  onValue(ref(db, "activePresentation"), async () => {
    const mapping = (await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`))).val();
    if (mapping && (typeof mapping === "string" || mapping.presentationId)) return;
    handlePresentationChange(false);
  });

  // If this monitor's mapping changes, respond in-place
  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), () => {
    handlePresentationChange(false);
  });
}

// ── Boot (initialise once) ────────────────────────────────────
async function boot() {
  setProgress(0, "Initializing…");
  monitorName = getPersistedMonitorName();
  await registerPresence(monitorName);
  attachCommandListener(monitorName);
  attachGlobalListeners();
  // initial fetch and start
  await fetchMediaAndMaybeRefreshPresentation();
  await handlePresentationChange(false);
}

boot();
</script>
</body>
</html>
