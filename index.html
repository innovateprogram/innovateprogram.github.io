<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Fullscreen View</title>
<style>
  *, *::before, *::after { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; padding: 0; background: #000; color: #fff; font-family: system-ui, Arial; cursor: none; overflow: hidden; }

  /* ── Preload screen ── */
  #preloadScreen {
    position: fixed; inset: 0; z-index: 9999;
    background: #0a0a0a;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 28px;
    transition: opacity 0.6s ease;
  }
  #preloadScreen.fade-out { opacity: 0; pointer-events: none; }

  #preloadLogo {
    font-size: 15px; font-weight: 700; letter-spacing: 0.18em;
    text-transform: uppercase; color: #555;
  }

  #preloadTitle {
    font-size: 22px; font-weight: 700; letter-spacing: 0.04em; color: #fff;
  }

  #preloadBarWrap {
    width: 320px; max-width: 80vw;
  }
  #preloadBarTrack {
    width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden;
  }
  #preloadBarFill {
    height: 100%; width: 0%; background: #fff;
    border-radius: 3px;
    transition: width 0.15s ease;
  }
  #preloadStatus {
    margin-top: 10px; font-size: 12px; color: #555;
    letter-spacing: 0.05em; text-align: center;
    min-height: 18px;
  }

  /* ── Presentation canvas ── */
  .canvas { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; }
  .slide { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; transition: opacity 800ms ease; opacity: 0; pointer-events: none; }
  .slide.visible { opacity: 1; pointer-events: auto; }
  .slide img, .slide video { max-width: 100%; max-height: 100%; object-fit: contain; }

  /* YouTube iframe */
  .yt-container { position: absolute; inset: 0; }
  .yt-container iframe { width: 100%; height: 100%; border: none; display: block; }

  /* Top-left banner overlay */
  @keyframes bannerIn {
    from { transform: translateX(-110%); }
    to   { transform: translateX(0); }
  }
  .overlay {
    position: absolute; top: 0; left: 0;
    padding: 18px 40px 18px 28px;
    border-radius: 0 0 12px 0;
    font-size: 28px; font-weight: 800; letter-spacing: 0.03em; line-height: 1.3;
    z-index: 100; max-width: 80vw; word-break: break-word;
    box-shadow: 6px 6px 0 rgba(0,0,0,0.35);
    animation: bannerIn 0.55s cubic-bezier(0.22, 1, 0.36, 1) both;
  }
</style>
</head>
<body>

<!-- Preload screen — shown until all media is cached -->
<div id="preloadScreen">
  <div id="preloadLogo">Innovate</div>
  <div id="preloadTitle">Loading Elements</div>
  <div id="preloadBarWrap">
    <div id="preloadBarTrack"><div id="preloadBarFill"></div></div>
    <div id="preloadStatus">Connecting…</div>
  </div>
</div>

<!-- Presentation (hidden until preload complete) -->
<div class="canvas" id="canvas" style="opacity:0;transition:opacity 0.6s ease"></div>
<div class="overlay" id="overlay" style="display:none"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, onValue, get } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);
const mediaDbRef = ref(db, "media");
const activeRef = ref(db, "activePresentation");
const refreshRef = ref(db, "refreshSignal");

// -- DOM --
const canvas = document.getElementById("canvas");
const overlayEl = document.getElementById("overlay");
const preloadScreen = document.getElementById("preloadScreen");
const preloadBarFill = document.getElementById("preloadBarFill");
const preloadStatus = document.getElementById("preloadStatus");

// -- State --
let mediaCache = {};       // Firebase media objects
let blobCache = {};        // mediaId -> blob URL (fully downloaded)
let presentation = null;
let slideIndex = 0;
let slideTimer = null;
let currentSlideEl = null;
let ytPlayers = {};
let ytApiReady = false;
let ytApiLoading = false;
let pendingYtInits = [];

// -- Refresh signal --
let refreshInitialSkipped = false;
onValue(refreshRef, () => {
  if (!refreshInitialSkipped) { refreshInitialSkipped = true; return; }
  location.reload(true);
});

// -- Preload UI helpers --
function setPreloadProgress(pct, label) {
  preloadBarFill.style.width = Math.min(100, pct) + "%";
  if (label !== undefined) preloadStatus.textContent = label;
}

function dismissPreloadScreen() {
  preloadScreen.classList.add("fade-out");
  canvas.style.opacity = "1";
  setTimeout(() => { preloadScreen.style.display = "none"; }, 650);
}

// -- Preload a single URL into a blob, with progress via XHR --
function fetchAsBlob(url) {
  return new Promise((resolve) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);
    xhr.responseType = "blob";
    xhr.onprogress = (e) => {
      // individual file progress handled at outer level
    };
    xhr.onload = () => {
      if (xhr.status < 400) resolve(URL.createObjectURL(xhr.response));
      else resolve(null); // failed  -  just continue
    };
    xhr.onerror = () => resolve(null);
    xhr.send();
  });
}

// -- Main boot: fetch Firebase data then preload all media --
async function boot() {
  setPreloadProgress(0, "Connecting to database...");

  // 1. Load media list + active presentation simultaneously
  const [mediaSnap, activeSnap] = await Promise.all([
    get(mediaDbRef),
    get(activeRef)
  ]);

  mediaCache = mediaSnap.val() || {};
  const activeId = activeSnap.val();

  let p = null;
  if (activeId) {
    const pSnap = await get(ref(db, `presentations/${activeId}`));
    p = pSnap.val();
  }
  if (!p) {
    const curSnap = await get(ref(db, "presentations/current"));
    p = curSnap.val();
  }

  if (!p || !p.items || p.items.length === 0) {
    setPreloadProgress(100, "No presentation found.");
    setTimeout(dismissPreloadScreen, 1200);
    return;
  }

  presentation = p;

  // 2. Collect all media URLs that need preloading (images + videos; skip YouTube)
  const toPreload = [];
  for (const item of p.items) {
    const m = mediaCache[item.mediaId];
    if (!m || !m.url) continue;
    if (m.resource_type === "youtube") continue;
    toPreload.push({ mediaId: item.mediaId, url: m.url, name: m.filename || item.mediaId });
  }

  // Deduplicate by mediaId
  const seen = new Set();
  const uniquePreload = toPreload.filter(x => {
    if (seen.has(x.mediaId)) return false;
    seen.add(x.mediaId); return true;
  });

  const total = uniquePreload.length;

  if (total === 0) {
    setPreloadProgress(100, "Ready.");
    await sleep(400);
    dismissPreloadScreen();
    renderPresentation(p);
    listenForChanges();
    return;
  }

  setPreloadProgress(0, `Loading 0 of ${total}...`);

  // 3. Download each file, store as blob URL
  for (let i = 0; i < uniquePreload.length; i++) {
    const { mediaId, url, name } = uniquePreload[i];
    const shortName = name.length > 30 ? name.slice(0, 28) + "..." : name;
    setPreloadProgress(
      Math.round((i / total) * 95),
      `Loading ${i + 1} of ${total}  -  ${shortName}`
    );
    const blobUrl = await fetchAsBlob(url);
    if (blobUrl) blobCache[mediaId] = blobUrl;
  }

  setPreloadProgress(100, "Ready.");
  await sleep(350);
  dismissPreloadScreen();
  renderPresentation(p);
  listenForChanges();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// -- Listen for live changes after initial load --
function listenForChanges() {
  // Re-render if presentation settings change (overlay, mode, etc.)
  // We only re-render if the items haven't changed (avoid re-downloading)
  onValue(activeRef, async snap => {
    const activeId = snap.val();
    let p = null;
    if (activeId) {
      const pSnap = await get(ref(db, `presentations/${activeId}`));
      p = pSnap.val();
    }
    if (!p) {
      const cur = await get(ref(db, "presentations/current"));
      p = cur.val();
    }
    if (!p) return;

    // Check if items changed  -  if so, we need to reload to re-preload new media
    const oldIds = (presentation?.items || []).map(i => i.mediaId).join(",");
    const newIds = (p.items || []).map(i => i.mediaId).join(",");
    if (oldIds !== newIds) {
      // New media added  -  do a full reload so it gets preloaded properly
      location.reload(true);
      return;
    }

    // Same items, just settings/overlay changed  -  update in place
    presentation = p;
    updateOverlay(p);
  });
}

// -- YouTube lazy loader --
function loadYtApiIfNeeded(callback) {
  if (ytApiReady) { callback(); return; }
  pendingYtInits.push(callback);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = () => {
    ytApiReady = true;
    pendingYtInits.forEach(fn => fn());
    pendingYtInits = [];
  };
  const tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

// -- Render presentation --
function destroyYtPlayers() {
  Object.values(ytPlayers).forEach(player => { try { player.destroy(); } catch(e) {} });
  ytPlayers = {};
}

function updateOverlay(p) {
  const overlayColor = p.overlay?.color || "#cc0000";
  const overlayTextColor = p.overlay?.textColor || "#ffffff";
  overlayEl.style.background = overlayColor;
  overlayEl.style.color = overlayTextColor;
  overlayEl.textContent = p.overlay?.text || "";
  if (p.overlay?.visible) {
    overlayEl.style.display = "block";
    overlayEl.style.animation = "none";
    void overlayEl.offsetWidth;
    overlayEl.style.animation = "";
  } else {
    overlayEl.style.display = "none";
  }
}

function renderPresentation(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  slideIndex = 0;
  canvas.querySelectorAll("video").forEach(v => v.pause());
  destroyYtPlayers();
  canvas.innerHTML = "";

  if (!p || !p.items || p.items.length === 0) {
    overlayEl.style.display = "none";
    return;
  }

  updateOverlay(p);

  p.items.forEach((it, idx) => {
    const m = mediaCache[it.mediaId];
    const slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;

    if (!m) {
      slide.innerHTML = `<div style="color:#fff;font-size:24px">Missing media: ${it.mediaId}</div>`;
    } else if (m.resource_type === "youtube") {
      const ytWrap = document.createElement("div");
      ytWrap.className = "yt-container";
      const ytDiv = document.createElement("div");
      ytDiv.id = `yt-player-${idx}`;
      ytWrap.appendChild(ytDiv);
      slide.appendChild(ytWrap);
    } else if (m.resource_type === "image") {
      const img = document.createElement("img");
      // Use blob URL if available, otherwise fall back to original
      img.src = blobCache[it.mediaId] || m.url;
      slide.appendChild(img);
    } else {
      const vid = document.createElement("video");
      // Use blob URL  -  already fully downloaded, plays instantly
      vid.src = blobCache[it.mediaId] || m.url;
      vid.setAttribute("playsinline", "");
      vid.preload = "auto";
      vid.controls = false;
      vid.style.maxWidth = "100%";
      vid.style.maxHeight = "100%";
      slide.appendChild(vid);
    }
    canvas.appendChild(slide);
  });

  showSlideAtIndex(p, 0);
}

// -- Slide navigation --
function showSlideAtIndex(p, idx) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (!p.items || p.items.length === 0) return;
  if (idx >= p.items.length) idx = 0;
  if (idx < 0) idx = 0;
  slideIndex = idx;

  const slides = Array.from(canvas.querySelectorAll(".slide"));

  slides.forEach(s => {
    const i = parseInt(s.dataset.idx, 10);
    if (i !== idx) {
      s.classList.remove("visible");
      const v = s.querySelector("video");
      if (v) { v.pause(); v.onended = null; }
      const ytPlayer = ytPlayers[i];
      if (ytPlayer) { try { ytPlayer.pauseVideo(); } catch(e) {} }
    }
  });

  const newSlide = slides.find(s => parseInt(s.dataset.idx, 10) === idx);
  if (!newSlide) return;

  newSlide.style.transition = p.transition === "cut" ? "none" : "opacity 800ms ease";
  void newSlide.offsetWidth;
  newSlide.classList.add("visible");
  currentSlideEl = newSlide;

  const item = p.items[idx];
  const media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }

  if (media.resource_type === "youtube") {
    playYouTubeSlide(p, idx, item, media);
  } else {
    const videoEl = newSlide.querySelector("video");
    if (videoEl) playVideoSlide(p, newSlide, videoEl, item);
    else scheduleNext(p);
  }
}

// -- Video playback (blob URLs mean no buffering wait) --
function playVideoSlide(p, slideEl, videoEl, item) {
  const start = item.start || 0;
  const end = item.end || null;
  videoEl.onended = null;
  videoEl.onloadedmetadata = null;

  const playFrom = () => {
    try {
      if (videoEl.duration && start <= videoEl.duration) {
        videoEl.currentTime = Math.min(start, videoEl.duration - 0.01);
      }
    } catch(e) {}
    videoEl.play().catch(() => {});
    if (end && end > start) {
      const checkEnd = () => {
        if (!slideEl.classList.contains("visible")) return;
        if (videoEl.currentTime >= end) { videoEl.pause(); advanceNow(p); }
        else requestAnimationFrame(checkEnd);
      };
      requestAnimationFrame(checkEnd);
    } else {
      videoEl.onended = () => advanceNow(p);
    }
  };

  if (videoEl.readyState >= 1) playFrom();
  else { videoEl.onloadedmetadata = () => playFrom(); videoEl.load(); }
}

// -- YouTube playback --
function playYouTubeSlide(p, idx, item, media) {
  const start = item.start != null ? item.start : (media.start || 0);
  const end = item.end != null ? item.end : (media.end || null);
  const ytId = media.ytId;

  const init = () => {
    if (ytPlayers[idx]) {
      const player = ytPlayers[idx];
      try {
        player.seekTo(start, true);
        player.playVideo();
        if (end && end > start) {
          const checkEnd = () => {
            const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
            if (!slide || !slide.classList.contains("visible")) return;
            try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advanceNow(p); return; } } catch(e) {}
            requestAnimationFrame(checkEnd);
          };
          requestAnimationFrame(checkEnd);
        }
      } catch(e) {}
      return;
    }

    const divId = `yt-player-${idx}`;
    if (!document.getElementById(divId)) return;

    new window.YT.Player(divId, {
      videoId: ytId,
      playerVars: { autoplay: 1, controls: 0, disablekb: 1, modestbranding: 1, rel: 0, start: Math.floor(start), mute: 0, playsinline: 1, enablejsapi: 1 },
      events: {
        onReady: (e) => {
          const player = e.target;
          ytPlayers[idx] = player;
          try { player.seekTo(start, true); } catch(err) {}
          player.playVideo();
          if (end && end > start) {
            const checkEnd = () => {
              const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
              if (!slide || !slide.classList.contains("visible")) return;
              try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advanceNow(p); return; } } catch(e) {}
              requestAnimationFrame(checkEnd);
            };
            requestAnimationFrame(checkEnd);
          }
        },
        onStateChange: (e) => { if (e.data === 0) advanceNow(p); }
      }
    });
  };

  loadYtApiIfNeeded(init);
}

function advanceNow(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  const next = (slideIndex + 1) % (p.items.length || 1);
  showSlideAtIndex(p, next);
}

function scheduleNext(p) {
  clearTimeout(slideTimer);
  slideTimer = null;
  if (p.mode === "single") return;
  const interval = p.intervalMs || 5000;
  slideTimer = setTimeout(() => {
    const next = (slideIndex + 1) % (p.items.length || 1);
    showSlideAtIndex(p, next);
  }, interval);
}

document.addEventListener("visibilitychange", () => {
  if (document.visibilityState === "visible" && presentation) {
    showSlideAtIndex(presentation, slideIndex);
  }
});

// -- Start --
boot();
</script>
</body>
</html>
