<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Display V2.6</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
        cursor: none;
      }
      #preload {
        position: fixed;
        inset: 0;
        z-index: 9999;
        background: #0a0a0a;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 24px;
        transition: opacity 0.5s ease;
      }
      #preload.out {
        opacity: 0;
        pointer-events: none;
      }
      #preload-logo {
        font-family: system-ui, sans-serif;
        font-size: 11px;
        font-weight: 700;
        letter-spacing: 0.2em;
        text-transform: uppercase;
        color: #444;
      }
      #preload-title {
        font-family: system-ui, sans-serif;
        font-size: 20px;
        font-weight: 600;
        color: #fff;
        letter-spacing: 0.02em;
      }
      #preload-track {
        width: 280px;
        height: 2px;
        background: #222;
        border-radius: 1px;
        overflow: hidden;
      }
      #preload-fill {
        height: 100%;
        width: 0%;
        background: #fff;
        border-radius: 1px;
        transition: width 0.2s ease;
      }
      #preload-status {
        font-family: system-ui, sans-serif;
        font-size: 11px;
        color: #444;
        letter-spacing: 0.05em;
      }
      .canvas {
        position: fixed;
        inset: 0;
        background: #000;
      }
      .slide {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        pointer-events: none;
      }
      .slide.cut {
        transition: none !important;
      }
      .slide.fade {
        transition: opacity 800ms ease;
      }
      .slide.visible {
        opacity: 1;
        pointer-events: auto;
      }
      .slide img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      .slide video {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
      .yt-wrap {
        position: absolute;
        inset: 0;
      }
      .yt-wrap iframe {
        width: 100%;
        height: 100%;
        border: none;
        display: block;
      }
      @keyframes bannerSlide {
        from {
          transform: translateX(-110%);
        }
        to {
          transform: translateX(0);
        }
      }
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        padding: 16px 36px 16px 24px;
        border-radius: 0 0 10px 0;
        font-family: system-ui, Arial, sans-serif;
        font-size: clamp(18px, 3vw, 34px);
        font-weight: 800;
        letter-spacing: 0.02em;
        line-height: 1.3;
        z-index: 100;
        max-width: 75vw;
        word-break: break-word;
        box-shadow: 4px 4px 0 rgba(0, 0, 0, 0.3);
        display: none;
        animation: bannerSlide 0.5s cubic-bezier(0.22, 1, 0.36, 1) both;
      }
    </style>
  </head>
  <body>
    <div id="preload">
      <div id="preload-logo">Innovate</div>
      <div id="preload-title">Loading…</div>
      <div id="preload-track"><div id="preload-fill"></div></div>
      <div id="preload-status">Connecting</div>
    </div>
    <div class="canvas" id="canvas" style="opacity: 0; transition: opacity 0.5s ease"></div>
    <div class="overlay" id="overlay"></div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
      import {
        getDatabase,
        ref,
        onValue,
        get,
        set,
        update,
        onDisconnect
      } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

      const firebaseConfig = {
        apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
        authDomain: "infinity-service-b2f10.firebaseapp.com",
        databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
        projectId: "infinity-service-b2f10",
        storageBucket: "infinity-service-b2f10.firebasestorage.app",
        messagingSenderId: "805770674259",
        appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
      };

      const app = initializeApp(firebaseConfig);
      const db = getDatabase(app);

      const canvas = document.getElementById("canvas");
      const overlayEl = document.getElementById("overlay");
      const preload = document.getElementById("preload");
      const preloadFill = document.getElementById("preload-fill");
      const preloadStatus = document.getElementById("preload-status");
      const preloadTitle = document.getElementById("preload-title");

      // ── State ──────────────────────────────────────────────────────────────────────
      let mediaCache = {};
      let slideEls = [];
      let presentation = null;
      let slideIndex = 0;
      let slideTimer = null;
      let ytPlayers = {};
      let ytApiReady = false;
      let ytApiLoading = false;
      let pendingYtInits = [];
      let monitorName = null;
      let lastCommandAt = 0;
      let currentPid = null; // presentation ID currently showing
      let syncEnabled = false;

      // Unique ID so we can ignore our own Firebase sync writes
      const DISPLAY_ID = Math.random().toString(36).slice(2);

      // ── Helpers ────────────────────────────────────────────────────────────────────
      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

      function setProgress(pct, label) {
        preloadFill.style.width = Math.min(100, Math.max(0, pct)) + "%";
        if (label != null) preloadStatus.textContent = label;
      }
      function dismissPreload() {
        preload.classList.add("out");
        canvas.style.opacity = "1";
        setTimeout(() => (preload.style.display = "none"), 600);
      }

      // ── Monitor identity ───────────────────────────────────────────────────────────
      function resetToFirstRun() {
        localStorage.clear();
        if ("caches" in window)
          caches
            .keys()
            .then((ks) => ks.forEach((k) => caches.delete(k)))
            .catch(() => {});
        window.location.reload();
      }

      async function getMonitorName() {
        try {
          const q = new URL(window.location.href).searchParams.get("monitor");
          if (q && q.trim()) {
            localStorage.setItem("monitorName", q.trim());
            return q.trim();
          }
        } catch (e) {}
        const ls = localStorage.getItem("monitorName");
        if (ls && ls.trim()) {
          const snap = await get(ref(db, `monitors/${encodeURIComponent(ls.trim())}`)).catch(() => null);
          if (snap && snap.val() === null) {
            resetToFirstRun();
            return null;
          }
          return ls.trim();
        }
        const p = prompt("Enter monitor name:", "");
        if (p && p.trim()) {
          localStorage.setItem("monitorName", p.trim());
          return p.trim();
        }
        return null;
      }

      // ── Presence ───────────────────────────────────────────────────────────────────
      async function registerPresence(name) {
        if (!name) return;
        const mRef = ref(db, `monitors/${encodeURIComponent(name)}`);
        const payload = { status: "online", lastSeen: Date.now(), resolution: `${screen.width}x${screen.height}` };
        await update(mRef, payload).catch(() => {});
        onDisconnect(mRef)
          .update({ status: "offline", lastSeen: Date.now() })
          .catch(() => {});
        setInterval(async () => {
          try {
            await update(mRef, { lastSeen: Date.now(), resolution: `${screen.width}x${screen.height}` });
          } catch (e) {}
        }, 5000);
      }

      // ── Resolve which presentation to show ─────────────────────────────────────────
      async function resolvePresentation(name) {
        if (!name) return { p: null, pid: null };
        const monSnap = await get(ref(db, `monitors/${encodeURIComponent(name)}`));
        const monData = monSnap.val();
        let pid = null;
        if (typeof monData === "string") pid = monData;
        else if (monData && typeof monData === "object")
          pid = monData.presentation || monData.assigned || monData.pid || null;

        if (pid) {
          const snap = await get(ref(db, `presentations/${pid}`));
          const p = snap.val();
          if (p && p.items && p.items.length) return { p, pid };
        }

        const activeSnap = await get(ref(db, "activePresentation"));
        const activeId = activeSnap.val();
        if (activeId) {
          const snap = await get(ref(db, `presentations/${activeId}`));
          const p = snap.val();
          if (p && p.items && p.items.length) return { p, pid: activeId };
        }

        const curSnap = await get(ref(db, "presentations/current"));
        return { p: curSnap.val(), pid: null };
      }

      // ── Sync state ─────────────────────────────────────────────────────────────────
      // Shape: { idx, startedAt, publisherId }

      function syncRef(pid) {
        return ref(db, `syncState/${pid}`);
      }

      async function publishSync(idx) {
        if (!syncEnabled || !currentPid) return;
        try {
          await set(syncRef(currentPid), { idx, startedAt: Date.now(), publisherId: DISPLAY_ID });
        } catch (e) {}
      }

      // Returns { idx, elapsed } to jump to on load, or { idx:0, elapsed:0 } if not synced
      async function readSync(pid, p) {
        if (!syncEnabled || !pid || !p?.items) return { idx: 0, elapsed: 0 };
        try {
          const snap = await get(syncRef(pid));
          const s = snap.val();
          if (!s || s.idx == null) return { idx: 0, elapsed: 0 };
          return { idx: s.idx, elapsed: Math.max(0, (Date.now() - s.startedAt) / 1000) };
        } catch (e) {
          return { idx: 0, elapsed: 0 };
        }
      }

      // ── Sync listener — ONE place, owned here ──────────────────────────────────────
      // Strategy: read current value first to get baseline, THEN attach onValue.
      // Only one listener exists at a time; reattach only when pid changes.

      let syncUnsub = null;
      let syncPid = null;

      async function ensureSyncListener(pid) {
        // Nothing to do if already watching the right pid
        if (pid === syncPid && syncUnsub) return;

        // Tear down old listener
        if (syncUnsub) {
          syncUnsub();
          syncUnsub = null;
        }
        syncPid = null;
        if (!pid) return;

        // Read the current value BEFORE attaching the live listener.
        // This gives us the "already handled" baseline so the first onValue
        // fire (which replays the current DB value) doesn't cause a spurious jump.
        let baseline = null;
        try {
          const snap = await get(syncRef(pid));
          const s = snap.val();
          if (s?.startedAt) baseline = s.startedAt;
        } catch (e) {}

        syncPid = pid;
        syncUnsub = onValue(syncRef(pid), (snap) => {
          const s = snap.val();
          if (!s || s.idx == null) return;

          // Skip the value that was already in the DB when we attached
          if (s.startedAt === baseline) return;
          baseline = s.startedAt; // update so we don't re-process

          // Ignore writes we made ourselves
          if (s.publisherId === DISPLAY_ID) return;

          // Only act if sync is on and we have slides loaded
          if (!syncEnabled || !presentation) return;

          const elapsed = Math.max(0, (Date.now() - s.startedAt) / 1000);
          showSlide(presentation, s.idx, elapsed, false);
        });
      }

      // ── Slide cleanup & build ──────────────────────────────────────────────────────
      function cleanupSlides() {
        clearTimeout(slideTimer);
        slideTimer = null;
        canvas.querySelectorAll(".slide").forEach((s) => {
          s.classList.remove("visible");
          const v = s.querySelector("video");
          if (v) {
            try {
              v.pause();
              v.onended = null;
            } catch (e) {}
          }
        });
        ytPlayers = {};
        slideEls = [];
        canvas.innerHTML = "";
      }

      function buildSlides(p) {
        cleanupSlides();
        if (!p?.items?.length) return;
        p.items.forEach((it, idx) => {
          const m = mediaCache[it.mediaId];
          const slide = document.createElement("div");
          slide.className = "slide";
          slide.dataset.idx = idx;
          if (!m) {
            slide.innerHTML = `<div style="color:#555;font-family:system-ui;font-size:20px">Missing media</div>`;
          } else if (m.resource_type === "youtube") {
            const wrap = document.createElement("div");
            wrap.className = "yt-wrap";
            const div = document.createElement("div");
            div.id = `yt-${idx}`;
            wrap.appendChild(div);
            slide.appendChild(wrap);
          } else if (m.resource_type === "image") {
            const img = document.createElement("img");
            img.src = m.url;
            slide.appendChild(img);
          } else {
            const vid = document.createElement("video");
            vid.src = m.url;
            vid.preload = "auto";
            vid.muted = true;
            vid.setAttribute("playsinline", "");
            slide.appendChild(vid);
          }
          canvas.appendChild(slide);
          slideEls.push(slide);
        });
      }

      // ── Wait helpers ───────────────────────────────────────────────────────────────
      function waitForVideo(vid, startTime) {
        return new Promise((resolve) => {
          let done = false;
          const finish = () => {
            if (done) return;
            done = true;
            resolve();
          };
          const timeout = setTimeout(finish, 12000);
          const checkReady = () => {
            if (vid.readyState >= 3) {
              clearTimeout(timeout);
              finish();
              return;
            }
            vid.addEventListener(
              "canplay",
              () => {
                clearTimeout(timeout);
                finish();
              },
              { once: true }
            );
          };
          const seekAndWait = () => {
            if (done) return;
            try {
              const st = startTime || 0;
              if (st > 0 && isFinite(vid.duration) && st < vid.duration) vid.currentTime = st;
            } catch (e) {}
            checkReady();
          };
          if (vid.readyState >= 1) seekAndWait();
          else vid.addEventListener("loadedmetadata", seekAndWait, { once: true });
          vid.load();
        });
      }

      function waitForImage(img) {
        return new Promise((resolve) => {
          if (img.complete && img.naturalWidth > 0) {
            resolve();
            return;
          }
          img.addEventListener("load", resolve, { once: true });
          img.addEventListener("error", resolve, { once: true });
        });
      }

      // ── Playback ───────────────────────────────────────────────────────────────────
      function showSlide(p, idx, seekOffset, publish) {
        clearTimeout(slideTimer);
        slideTimer = null;
        if (!p?.items?.length) return;
        idx = ((idx % p.items.length) + p.items.length) % p.items.length;
        slideIndex = idx;

        const isCut = p.transition === "cut";
        canvas.querySelectorAll(".slide").forEach((s) => {
          if (parseInt(s.dataset.idx, 10) === idx) return;
          s.classList.remove("visible");
          const v = s.querySelector("video");
          if (v) {
            v.pause();
            v.onended = null;
          }
          try {
            ytPlayers[parseInt(s.dataset.idx, 10)]?.pauseVideo();
          } catch (e) {}
        });

        const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
        if (!slide) return;
        slide.className = "slide " + (isCut ? "cut" : "fade");
        void slide.offsetWidth;
        slide.classList.add("visible");

        // Publish AFTER showing so other displays can follow
        if (publish) publishSync(idx);

        const item = p.items[idx];
        const media = mediaCache[item.mediaId];
        if (!media) {
          scheduleNext(p);
          return;
        }

        if (media.resource_type === "youtube") {
          playYT(p, idx, item, media, seekOffset || 0);
        } else if (media.resource_type !== "image") {
          const vid = slide.querySelector("video");
          if (vid) playVideo(p, slide, vid, item, seekOffset || 0);
          else scheduleNext(p);
        } else {
          // Image — account for elapsed time when syncing
          if (seekOffset && p.intervalMs) {
            const remaining = Math.max(500, p.intervalMs - seekOffset * 1000);
            slideTimer = setTimeout(() => advance(p), remaining);
          } else {
            scheduleNext(p);
          }
        }
      }

      function playVideo(p, slideEl, vid, item, seekOffset) {
        const start = (item.start || 0) + (seekOffset || 0);
        const end = item.end || null;
        vid.onended = null;

        const attemptPlay = () => {
          try {
            if (isFinite(vid.duration) && start > 0 && start < vid.duration) vid.currentTime = start;
            else if (start === 0) vid.currentTime = 0;
          } catch (e) {}

          vid.muted = true;
          vid
            .play()
            .then(() => {
              vid.muted = false;
              if (end && end > start) {
                const poll = () => {
                  if (!slideEl.classList.contains("visible")) return;
                  vid.currentTime >= end ? (vid.pause(), advance(p)) : requestAnimationFrame(poll);
                };
                requestAnimationFrame(poll);
              } else {
                vid.onended = () => advance(p);
              }
            })
            .catch((err) => {
              console.warn("Video play failed:", err);
              scheduleNext(p);
            });
        };

        if (vid.readyState >= 1) attemptPlay();
        else {
          vid.addEventListener("loadedmetadata", attemptPlay, { once: true });
          vid.load();
        }
      }

      function scheduleNext(p) {
        clearTimeout(slideTimer);
        slideTimer = null;
        if (p.mode === "single") return;
        slideTimer = setTimeout(() => advance(p), p.intervalMs || 5000);
      }

      function advance(p) {
        clearTimeout(slideTimer);
        slideTimer = null;
        if (!p || p.mode === "single") return;
        showSlide(p, slideIndex + 1, 0, true);
      }

      // ── YouTube ────────────────────────────────────────────────────────────────────
      function loadYtApi(cb) {
        if (ytApiReady) {
          cb();
          return;
        }
        pendingYtInits.push(cb);
        if (ytApiLoading) return;
        ytApiLoading = true;
        window.onYouTubeIframeAPIReady = () => {
          ytApiReady = true;
          pendingYtInits.forEach((fn) => fn());
          pendingYtInits = [];
        };
        const tag = document.createElement("script");
        tag.src = "https://www.youtube.com/iframe_api";
        document.head.appendChild(tag);
      }

      function playYT(p, idx, item, media, seekOffset) {
        const base = item.start ?? media.start ?? 0;
        const start = base + (seekOffset || 0);
        const end = item.end ?? media.end ?? null;

        loadYtApi(() => {
          if (ytPlayers[idx]) {
            const pl = ytPlayers[idx];
            try {
              pl.seekTo(start, true);
              pl.unMute();
              pl.setVolume(100);
              pl.playVideo();
            } catch (e) {}
            if (end && end > start) pollYt(p, idx, pl, end);
            return;
          }
          const divId = `yt-${idx}`;
          if (!document.getElementById(divId)) return;
          new window.YT.Player(divId, {
            videoId: media.ytId,
            playerVars: {
              autoplay: 1,
              controls: 0,
              disablekb: 1,
              modestbranding: 1,
              rel: 0,
              start: Math.floor(start),
              mute: 1,
              playsinline: 1,
              enablejsapi: 1,
              iv_load_policy: 3,
              fs: 0
            },
            events: {
              onReady: (e) => {
                ytPlayers[idx] = e.target;
                e.target.mute();
                try {
                  e.target.seekTo(start, true);
                } catch (err) {}
                e.target.playVideo();
                setTimeout(() => {
                  try {
                    e.target.unMute();
                    e.target.setVolume(100);
                  } catch (err) {}
                }, 500);
                if (end && end > start) pollYt(p, idx, e.target, end);
              },
              onStateChange: (e) => {
                if (e.data === 0) advance(p);
                if (e.data === 1)
                  setTimeout(() => {
                    try {
                      e.target.unMute();
                      e.target.setVolume(100);
                    } catch (err) {}
                  }, 300);
              },
              onError: (e) => {
                console.warn("YT error:", e.data);
                advance(p);
              }
            }
          });
        });
      }

      function pollYt(p, idx, player, end) {
        const check = () => {
          const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
          if (!slide?.classList.contains("visible")) return;
          try {
            if (player.getCurrentTime() >= end) {
              player.pauseVideo();
              advance(p);
              return;
            }
          } catch (e) {}
          requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
      }

      // ── Overlay ────────────────────────────────────────────────────────────────────
      let overlayVisible = false;
      function applyOverlay(p, animate) {
        const ov = p.overlay || {};
        if (ov.visible && ov.text) {
          overlayEl.style.background = ov.color || "#cc0000";
          overlayEl.style.color = ov.textColor || "#fff";
          overlayEl.textContent = ov.text;
          overlayEl.style.display = "block";
          if (animate && !overlayVisible) {
            overlayEl.style.animation = "none";
            void overlayEl.offsetWidth;
            overlayEl.style.animation = "";
          }
          overlayVisible = true;
        } else {
          overlayEl.style.display = "none";
          overlayVisible = false;
        }
      }

      // ── Main load / reload ─────────────────────────────────────────────────────────
      let currentPresentationKey = null;

      async function loadPresentation(forceReload = false) {
        const { p, pid } = await resolvePresentation(monitorName);

        if (!p?.items?.length) {
          setProgress(100, "No slides found");
          await sleep(600);
          dismissPreload();
          return;
        }

        // Update globals BEFORE anything that reads them
        syncEnabled = !!p.syncPlayback;
        currentPid = pid;

        // If only settings changed (overlay, interval, etc.) — no rebuild needed
        const key = JSON.stringify(p.items.map((i) => i.mediaId)) + p.name + p.intervalMs + p.transition;
        if (!forceReload && key === currentPresentationKey) {
          presentation = p;
          applyOverlay(p, true);
          // Re-attach sync listener in case syncEnabled just changed
          await ensureSyncListener(syncEnabled ? pid : null);
          return;
        }
        currentPresentationKey = key;

        // Full rebuild
        setProgress(5, "Fetching media…");
        const mediaSnap = await get(ref(db, "media"));
        mediaCache = mediaSnap.val() || {};

        presentation = p;
        buildSlides(p);

        // Preload assets
        let loaded = 0;
        const total = p.items.length;
        await Promise.all(
          p.items.map(async (it, idx) => {
            const m = mediaCache[it.mediaId];
            if (!m || m.resource_type === "youtube") {
              loaded++;
              setProgress(10 + (loaded / total) * 85, `${loaded}/${total}`);
              return;
            }
            const slide = slideEls[idx];
            if (m.resource_type === "image") {
              await waitForImage(slide.querySelector("img"));
            } else {
              await waitForVideo(slide.querySelector("video"), it.start || 0);
            }
            loaded++;
            setProgress(10 + (loaded / total) * 85, `${loaded}/${total}`);
          })
        );

        setProgress(100, "Ready");
        await sleep(200);
        dismissPreload();
        applyOverlay(p, true);

        // Set up sync listener — do this BEFORE reading sync state.
        // ensureSyncListener reads the current DB value to set its baseline,
        // so when we then call readSync() we're reading the same snapshot.
        // After this point, any NEW writes from other displays will trigger the listener.
        await ensureSyncListener(syncEnabled ? pid : null);

        // Jump to the current sync position (or slide 0 if not synced)
        const { idx: startIdx, elapsed } = await readSync(pid, p);
        showSlide(p, startIdx, elapsed, false);
      }

      // ── Firebase change listeners ──────────────────────────────────────────────────
      // All roads lead to loadPresentation(). We debounce to avoid hammering it.

      let reloadDebounce = null;
      function scheduleReload(force = false) {
        clearTimeout(reloadDebounce);
        reloadDebounce = setTimeout(() => loadPresentation(force), 350);
      }

      function attachListeners() {
        const monKey = encodeURIComponent(monitorName);

        // Watch for commands (reload button in manager)
        onValue(ref(db, `monitors/${monKey}/command`), (snap) => {
          const cmd = snap.val();
          if (!cmd?.at || cmd.at <= lastCommandAt) return;
          lastCommandAt = cmd.at;
          if (cmd.cmd === "reloadPresentation") loadPresentation(true);
        });

        // Watch monitor record (assignment changes, deletion)
        let monFirstFire = true;
        onValue(ref(db, `monitors/${monKey}`), (snap) => {
          if (monFirstFire) {
            monFirstFire = false;
            return;
          }
          if (snap.val() === null) {
            resetToFirstRun();
            return;
          }
          scheduleReload(false);
        });

        // Watch the assigned presentation directly for live edits
        // Track which presentation we're watching so we can switch
        let watchedPid = null;
        let presentationUnsub = null;

        async function updatePresentationWatch() {
          const monSnap = await get(ref(db, `monitors/${monKey}`));
          const monData = monSnap.val();
          let pid = null;
          if (typeof monData === "string") pid = monData;
          else if (monData && typeof monData === "object")
            pid = monData.presentation || monData.assigned || monData.pid || null;

          if (pid === watchedPid) return;
          watchedPid = pid;

          if (presentationUnsub) {
            presentationUnsub();
            presentationUnsub = null;
          }
          if (!pid) return;

          let presFirstFire = true;
          presentationUnsub = onValue(ref(db, `presentations/${pid}`), (snap) => {
            if (presFirstFire) {
              presFirstFire = false;
              return;
            }
            if (!snap.val()) return;
            // Update syncEnabled immediately so the sync listener check is current
            syncEnabled = !!snap.val().syncPlayback;
            scheduleReload(false);
          });
        }

        // Re-run updatePresentationWatch whenever monitor record changes
        let monWatchFirstFire = true;
        onValue(ref(db, `monitors/${monKey}`), () => {
          if (monWatchFirstFire) {
            monWatchFirstFire = false;
            return;
          }
          updatePresentationWatch();
        });

        // Watch activePresentation (fallback for unassigned monitors)
        let activeFirstFire = true;
        onValue(ref(db, "activePresentation"), async () => {
          if (activeFirstFire) {
            activeFirstFire = false;
            return;
          }
          // Only matters if this monitor has no specific assignment
          const monSnap = await get(ref(db, `monitors/${monKey}`));
          const monData = monSnap.val();
          let pid = null;
          if (typeof monData === "object" && monData)
            pid = monData.presentation || monData.assigned || monData.pid || null;
          if (!pid) scheduleReload(false);
        });

        // Watch presentations/current (legacy fallback)
        let curFirstFire = true;
        onValue(ref(db, "presentations/current"), async () => {
          if (curFirstFire) {
            curFirstFire = false;
            return;
          }
          const monSnap = await get(ref(db, `monitors/${monKey}`));
          const monData = monSnap.val();
          let pid = null;
          if (typeof monData === "object" && monData)
            pid = monData.presentation || monData.assigned || monData.pid || null;
          if (!pid) scheduleReload(false);
        });

        // Global refresh signal (Refresh Displays button)
        let lastRefreshSignal = null;
        onValue(ref(db, "refreshSignal"), (snap) => {
          const val = snap.val();
          if (lastRefreshSignal === null) {
            lastRefreshSignal = val;
            return;
          }
          if (val !== lastRefreshSignal) {
            lastRefreshSignal = val;
            window.location.reload();
          }
        });
      }

      // ── Boot ───────────────────────────────────────────────────────────────────────
      async function boot() {
        setProgress(0, "Connecting…");
        monitorName = await getMonitorName();
        if (!monitorName) return;
        preloadTitle.textContent = monitorName;
        await registerPresence(monitorName);
        attachListeners();
        await loadPresentation(false);
      }

      boot();
    </script>
  </body>
</html>
