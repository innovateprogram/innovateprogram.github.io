<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Display</title>
<style>
*, *::before, *::after { box-sizing: border-box; }
html, body { height: 100%; margin: 0; padding: 0; background: #000; overflow: hidden; cursor: none; }

#preload {
  position: fixed; inset: 0; z-index: 9999;
  background: #0a0a0a;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  gap: 24px;
  transition: opacity 0.5s ease;
}
#preload.out { opacity: 0; pointer-events: none; }
#preload-logo { font-family: system-ui, sans-serif; font-size: 11px; font-weight: 700; letter-spacing: 0.2em; text-transform: uppercase; color: #444; }
#preload-title { font-family: system-ui, sans-serif; font-size: 20px; font-weight: 600; color: #fff; letter-spacing: 0.02em; }
#preload-track { width: 280px; height: 2px; background: #222; border-radius: 1px; overflow: hidden; }
#preload-fill { height: 100%; width: 0%; background: #fff; border-radius: 1px; transition: width 0.2s ease; }
#preload-status { font-family: system-ui, sans-serif; font-size: 11px; color: #444; letter-spacing: 0.05em; }

.canvas { position: fixed; inset: 0; background: #000; }
.slide { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; }
.slide.cut { transition: none !important; }
.slide.fade { transition: opacity 800ms ease; }
.slide.visible { opacity: 1; pointer-events: auto; }
.slide img { width: 100%; height: 100%; object-fit: contain; }
.slide video { width: 100%; height: 100%; object-fit: contain; }

.yt-wrap { position: absolute; inset: 0; }
.yt-wrap iframe { width: 100%; height: 100%; border: none; display: block; }

@keyframes bannerSlide { from { transform: translateX(-110%); } to { transform: translateX(0); } }
.overlay {
  position: absolute; top: 0; left: 0;
  padding: 16px 36px 16px 24px;
  border-radius: 0 0 10px 0;
  font-family: system-ui, Arial, sans-serif;
  font-size: clamp(18px, 3vw, 34px);
  font-weight: 800; letter-spacing: 0.02em; line-height: 1.3;
  z-index: 100; max-width: 75vw; word-break: break-word;
  box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
  display: none;
  animation: bannerSlide 0.5s cubic-bezier(0.22,1,0.36,1) both;
}
</style>
</head>
<body>

<div id="preload">
  <div id="preload-logo">Innovate</div>
  <div id="preload-title">Loading…</div>
  <div id="preload-track"><div id="preload-fill"></div></div>
  <div id="preload-status">Connecting</div>
</div>

<div class="canvas" id="canvas" style="opacity:0;transition:opacity 0.5s ease"></div>
<div class="overlay" id="overlay"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, onValue, get, set, update, onDisconnect } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyBgV9PoUFut3FPc0iChFNm2-h6-Uc5z6s0",
  authDomain: "infinity-service-b2f10.firebaseapp.com",
  databaseURL: "https://infinity-service-b2f10-default-rtdb.firebaseio.com",
  projectId: "infinity-service-b2f10",
  storageBucket: "infinity-service-b2f10.firebasestorage.app",
  messagingSenderId: "805770674259",
  appId: "1:805770674259:web:bcc520979e6772fda5c6a6"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const canvas = document.getElementById("canvas");
const overlayEl = document.getElementById("overlay");
const preload = document.getElementById("preload");
const preloadFill = document.getElementById("preload-fill");
const preloadStatus = document.getElementById("preload-status");
const preloadTitle = document.getElementById("preload-title");

let mediaCache = {};
let slideEls = [];
let presentation = null;
let slideIndex = 0;
let slideTimer = null;
let ytPlayers = {};
let ytApiReady = false;
let ytApiLoading = false;
let pendingYtInits = [];
let monitorName = null;
let monitorRef = null;
let lastCommandAt = 0;
let syncEnabled = false;
let currentPresentationId = null; // track which pres we're showing

// ── Preload UI ─────────────────────────────────────────────────────────────────
function setProgress(pct, label) {
  preloadFill.style.width = Math.min(100, Math.max(0, pct)) + "%";
  if (label != null) preloadStatus.textContent = label;
}
function dismissPreload() {
  preload.classList.add("out");
  canvas.style.opacity = "1";
  setTimeout(() => preload.style.display = "none", 600);
}
function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ── Monitor identity ───────────────────────────────────────────────────────────

// Wipe all local state so the display acts as if it's never been set up
function resetToFirstRun() {
  localStorage.clear();
  // Also clear any session/app caches if available
  if ("caches" in window) {
    caches.keys().then(keys => keys.forEach(k => caches.delete(k))).catch(() => {});
  }
  window.location.reload();
}

async function getMonitorName() {
  // ?monitor= param always takes precedence (kiosk/URL-pinned displays)
  try {
    const q = new URL(window.location.href).searchParams.get("monitor");
    if (q && q.trim()) {
      localStorage.setItem("monitorName", q.trim());
      return q.trim();
    }
  } catch(e) {}

  const ls = localStorage.getItem("monitorName");
  if (ls && ls.trim()) {
    // Check Firebase — if this monitor was deleted from the dashboard, start fresh
    const key = encodeURIComponent(ls.trim());
    const snap = await get(ref(db, `monitors/${key}`)).catch(() => null);
    if (snap && snap.val() === null) {
      // Record exists in Firebase path but is null = was explicitly deleted
      resetToFirstRun();
      return null; // won't reach here due to reload
    }
    return ls.trim();
  }

  const p = prompt("Enter monitor name:", "");
  if (p && p.trim()) { localStorage.setItem("monitorName", p.trim()); return p.trim(); }
  return null;
}

// ── Presence / heartbeat ───────────────────────────────────────────────────────
async function registerPresence(name) {
  if (!name) return;
  const key = encodeURIComponent(name);
  monitorRef = ref(db, `monitors/${key}`);
  const presencePayload = {
    status: "online",
    lastSeen: Date.now(),
    resolution: `${screen.width}x${screen.height}`
  };
  await update(monitorRef, presencePayload).catch(() => {});
  onDisconnect(monitorRef).update({ status: "offline", lastSeen: Date.now() }).catch(() => {});
  setInterval(async () => {
    try { await update(monitorRef, { lastSeen: Date.now(), resolution: `${screen.width}x${screen.height}` }); } catch(e) {}
  }, 5000);
}

// ── Commands ───────────────────────────────────────────────────────────────────
function attachCommandListener(name) {
  if (!name) return;
  onValue(ref(db, `monitors/${encodeURIComponent(name)}/command`), snap => {
    const cmd = snap.val();
    if (!cmd || !cmd.at || cmd.at <= lastCommandAt) return;
    lastCommandAt = cmd.at;
    if (cmd.cmd === "reloadPresentation") handlePresentationChange(true);
  });
}

// ── Presentation resolution ────────────────────────────────────────────────────
async function resolvePresentation(name) {
  if (!name) return { p: null, pid: null };
  const key = encodeURIComponent(name);
  const monSnap = await get(ref(db, `monitors/${key}`));
  const monData = monSnap.val();

  let pid = null;
  if (typeof monData === "string") pid = monData;
  else if (monData && typeof monData === "object") {
    pid = monData.presentation || monData.assigned || monData.pid || null;
  }

  if (pid) {
    const snap = await get(ref(db, `presentations/${pid}`));
    const p = snap.val();
    if (p && p.items && p.items.length) return { p, pid };
  }

  const activeSnap = await get(ref(db, "activePresentation"));
  const activeId = activeSnap.val();
  if (activeId) {
    const snap = await get(ref(db, `presentations/${activeId}`));
    const p = snap.val();
    if (p && p.items && p.items.length) return { p, pid: activeId };
  }

  const curSnap = await get(ref(db, "presentations/current"));
  return { p: curSnap.val(), pid: null };
}

// ── Sync state ─────────────────────────────────────────────────────────────────
// syncState in Firebase: { idx: number, startedAt: timestamp }
// This lets any display joining mid-show jump to the correct slide & seek position.

function getSyncRef(pid) {
  return ref(db, `syncState/${pid}`);
}

async function publishSyncState(pid, idx) {
  if (!syncEnabled || !pid) return;
  try {
    await set(getSyncRef(pid), { idx, startedAt: Date.now() });
  } catch(e) {}
}

// Given syncState + presentation, figure out which slide index we should be on
// and how far into that slide we are (for video/YT seeking).
async function readSyncState(pid, p) {
  if (!syncEnabled || !pid || !p || !p.items) return { idx: 0, elapsed: 0 };
  try {
    const snap = await get(getSyncRef(pid));
    const s = snap.val();
    if (!s || s.idx == null) return { idx: 0, elapsed: 0 };
    const elapsed = (Date.now() - s.startedAt) / 1000; // seconds since slide started
    return { idx: s.idx, elapsed };
  } catch(e) {
    return { idx: 0, elapsed: 0 };
  }
}

// ── Cleanup ────────────────────────────────────────────────────────────────────
function cleanupSlides() {
  clearTimeout(slideTimer); slideTimer = null;
  canvas.querySelectorAll(".slide").forEach(s => {
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { try { v.pause(); v.onended = null; } catch(e){} }
  });
  ytPlayers = {};
  slideEls = [];
  canvas.innerHTML = "";
}

// ── Build slides ───────────────────────────────────────────────────────────────
function buildSlides(p) {
  cleanupSlides();
  if (!p || !p.items || !p.items.length) return;
  p.items.forEach((it, idx) => {
    const m = mediaCache[it.mediaId];
    const slide = document.createElement("div");
    slide.className = "slide";
    slide.dataset.idx = idx;
    if (!m) {
      slide.innerHTML = `<div style="color:#555;font-family:system-ui;font-size:20px">Missing media</div>`;
    } else if (m.resource_type === "youtube") {
      const wrap = document.createElement("div"); wrap.className = "yt-wrap";
      const div = document.createElement("div"); div.id = `yt-${idx}`;
      wrap.appendChild(div); slide.appendChild(wrap);
    } else if (m.resource_type === "image") {
      const img = document.createElement("img"); img.src = m.url; slide.appendChild(img);
    } else {
      const vid = document.createElement("video");
      vid.src = m.url; vid.preload = "auto"; vid.muted = true; vid.setAttribute("playsinline","");
      slide.appendChild(vid);
    }
    canvas.appendChild(slide);
    slideEls.push(slide);
  });
}

// ── Wait helpers ───────────────────────────────────────────────────────────────
function waitForVideo(vid, startTime) {
  return new Promise(resolve => {
    let done = false;
    const finish = () => { if (done) return; done = true; resolve(); };
    const timeout = setTimeout(finish, 12000);
    const checkReady = () => {
      if (vid.readyState >= 3) { clearTimeout(timeout); finish(); return; }
      vid.addEventListener("canplay", () => { clearTimeout(timeout); finish(); }, { once: true });
    };
    const seekAndWait = () => {
      if (done) return;
      const st = startTime || 0;
      try { if (st > 0 && isFinite(vid.duration) && st < vid.duration) vid.currentTime = st; } catch(e) {}
      checkReady();
    };
    if (vid.readyState >= 1) seekAndWait();
    else vid.addEventListener("loadedmetadata", seekAndWait, { once: true });
    vid.load();
  });
}
function waitForImage(img) {
  return new Promise(resolve => {
    if (img.complete && img.naturalWidth > 0) { resolve(); return; }
    img.addEventListener("load", resolve, { once: true });
    img.addEventListener("error", resolve, { once: true });
  });
}

// ── Playback ───────────────────────────────────────────────────────────────────
function showSlide(p, idx, seekOffset, publish) {
  clearTimeout(slideTimer); slideTimer = null;
  if (!p || !p.items || !p.items.length) return;
  idx = ((idx % p.items.length) + p.items.length) % p.items.length;
  slideIndex = idx;

  const isCut = p.transition === "cut";
  canvas.querySelectorAll(".slide").forEach(s => {
    const i = parseInt(s.dataset.idx, 10);
    if (i === idx) return;
    s.classList.remove("visible");
    const v = s.querySelector("video");
    if (v) { v.pause(); v.onended = null; }
    const pl = ytPlayers[i];
    if (pl) { try { pl.pauseVideo(); } catch(e){} }
  });

  const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
  if (!slide) return;
  slide.className = "slide " + (isCut ? "cut" : "fade");
  void slide.offsetWidth;
  slide.classList.add("visible");

  // Only publish when THIS display is advancing naturally — not when catching up to sync
  if (publish && currentPresentationId) publishSyncState(currentPresentationId, idx);

  const item = p.items[idx];
  const media = mediaCache[item.mediaId];
  if (!media) { scheduleNext(p); return; }

  if (media.resource_type === "youtube") {
    playYT(p, idx, item, media, seekOffset || 0);
  } else if (media.resource_type !== "image") {
    const vid = slide.querySelector("video");
    if (vid) playVideo(p, slide, vid, item, seekOffset || 0);
    else scheduleNext(p);
  } else {
    // Image: if synced, adjust timer to remaining time
    if (seekOffset && p.intervalMs) {
      const remaining = Math.max(500, p.intervalMs - (seekOffset * 1000));
      slideTimer = setTimeout(() => advance(p), remaining);
    } else {
      scheduleNext(p);
    }
  }
}

function playVideo(p, slideEl, vid, item, seekOffset) {
  const start = (item.start || 0) + (seekOffset || 0);
  const end = item.end || null;
  vid.onended = null;
  vid.muted = false;
  try { if (isFinite(vid.duration) && start < vid.duration) vid.currentTime = start; } catch(e){}
  vid.play().catch(() => {});
  if (end && end > start) {
    const poll = () => {
      if (!slideEl.classList.contains("visible")) return;
      if (vid.currentTime >= end) { vid.pause(); advance(p); }
      else requestAnimationFrame(poll);
    };
    requestAnimationFrame(poll);
  } else {
    vid.onended = () => advance(p);
  }
}

function scheduleNext(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (p.mode === "single") return;
  slideTimer = setTimeout(() => advance(p), p.intervalMs || 5000);
}

function advance(p) {
  clearTimeout(slideTimer); slideTimer = null;
  if (!p || p.mode === "single") return;
  showSlide(p, slideIndex + 1, 0, true);
}

// ── YouTube with autoplay bypass ───────────────────────────────────────────────
function loadYtApi(cb) {
  if (ytApiReady) { cb(); return; }
  pendingYtInits.push(cb);
  if (ytApiLoading) return;
  ytApiLoading = true;
  window.onYouTubeIframeAPIReady = () => {
    ytApiReady = true;
    pendingYtInits.forEach(fn => fn());
    pendingYtInits = [];
  };
  const tag = document.createElement("script");
  tag.src = "https://www.youtube.com/iframe_api";
  document.head.appendChild(tag);
}

function playYT(p, idx, item, media, seekOffset) {
  const baseStart = (item.start != null) ? item.start : (media.start != null ? media.start : 0);
  const start = baseStart + (seekOffset || 0);
  const end = (item.end != null) ? item.end : (media.end != null ? media.end : null);

  loadYtApi(() => {
    if (ytPlayers[idx]) {
      const pl = ytPlayers[idx];
      try {
        pl.seekTo(start, true);
        pl.unMute();
        pl.setVolume(100);
        pl.playVideo();
      } catch(e){}
      if (end && end > start) pollYt(p, idx, pl, end);
      return;
    }

    const divId = `yt-${idx}`;
    if (!document.getElementById(divId)) return;

    new window.YT.Player(divId, {
      videoId: media.ytId,
      playerVars: {
        autoplay: 1, controls: 0, disablekb: 1, modestbranding: 1, rel: 0,
        start: Math.floor(start), mute: 1, playsinline: 1, enablejsapi: 1,
        iv_load_policy: 3, fs: 0
      },
      events: {
        onReady: function(e) {
          ytPlayers[idx] = e.target;
          e.target.mute();
          try { e.target.seekTo(start, true); } catch(err){}
          e.target.playVideo();
          setTimeout(() => {
            try { e.target.unMute(); e.target.setVolume(100); } catch(err) {}
          }, 500);
          if (end && end > start) pollYt(p, idx, e.target, end);
        },
        onStateChange: function(e) {
          if (e.data === 0) advance(p);
          if (e.data === 1) {
            setTimeout(() => {
              try { e.target.unMute(); e.target.setVolume(100); } catch(err){}
            }, 300);
          }
        },
        onError: function(e) { console.warn("YT player error:", e.data); advance(p); }
      }
    });
  });
}

function pollYt(p, idx, player, end) {
  const check = () => {
    const slide = canvas.querySelector(`.slide[data-idx="${idx}"]`);
    if (!slide || !slide.classList.contains("visible")) return;
    try { if (player.getCurrentTime() >= end) { player.pauseVideo(); advance(p); return; } } catch(e){}
    requestAnimationFrame(check);
  };
  requestAnimationFrame(check);
}

// ── Overlay ────────────────────────────────────────────────────────────────────
let overlayVisible = false;
function applyOverlay(p, animate) {
  const ov = p.overlay || {};
  if (ov.visible && ov.text) {
    overlayEl.style.background = ov.color || "#cc0000";
    overlayEl.style.color = ov.textColor || "#fff";
    overlayEl.textContent = ov.text;
    overlayEl.style.display = "block";
    if (animate && !overlayVisible) {
      overlayEl.style.animation = "none";
      void overlayEl.offsetWidth;
      overlayEl.style.animation = "";
    }
    overlayVisible = true;
  } else {
    overlayEl.style.display = "none";
    overlayVisible = false;
  }
}

// ── Presentation change / reload ───────────────────────────────────────────────
let currentPresentationKey = null;

async function handlePresentationChange(forceReload) {
  const { p, pid } = await resolvePresentation(monitorName);

  if (!p || !p.items || !p.items.length) {
    setProgress(100, "No slides found");
    await sleep(600);
    dismissPreload();
    return;
  }

  syncEnabled = !!p.syncPlayback;
  currentPresentationId = pid;

  const fp = JSON.stringify(p.items.map(i => i.mediaId)) + p.name + p.intervalMs + p.transition;
  if (!forceReload && fp === currentPresentationKey) {
    presentation = p;
    applyOverlay(p, true);
    return;
  }
  currentPresentationKey = fp;

  setProgress(5, "Fetching media…");
  const mediaSnap = await get(ref(db, "media"));
  mediaCache = mediaSnap.val() || {};

  presentation = p;
  buildSlides(p);

  let loaded = 0;
  const total = p.items.length;
  const promises = p.items.map((it, idx) => {
    const m = mediaCache[it.mediaId];
    if (!m || m.resource_type === "youtube") {
      return Promise.resolve().then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    }
    const slide = slideEls[idx];
    if (m.resource_type === "image") {
      const img = slide.querySelector("img");
      return waitForImage(img).then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    } else {
      const vid = slide.querySelector("video");
      return waitForVideo(vid, it.start || 0).then(() => { loaded++; setProgress(10 + (loaded/total)*85, `${loaded}/${total}`); });
    }
  });

  await Promise.all(promises);
  setProgress(100, "Ready");
  await sleep(200);
  dismissPreload();
  applyOverlay(p, true);

  // Read sync state to jump to the right slide
  const { idx: syncIdx, elapsed } = await readSyncState(pid, p);
  slideIndex = 0;
  showSlide(p, syncIdx, elapsed, false);
}

// ── Live update listeners ──────────────────────────────────────────────────────
let changeDebounceTimer = null;
function debouncedPresentationChange(force) {
  clearTimeout(changeDebounceTimer);
  changeDebounceTimer = setTimeout(() => handlePresentationChange(force), 300);
}

// Live sync listener - when another display advances, follow it
let syncUnsub = null;
function attachSyncListener(pid) {
  if (syncUnsub) { syncUnsub(); syncUnsub = null; }
  if (!pid) return;
  let firstFire = true;
  syncUnsub = onValue(getSyncRef(pid), snap => {
    if (firstFire) { firstFire = false; return; }
    if (!syncEnabled || !presentation) return;
    const s = snap.val();
    if (!s || s.idx == null) return;
    const elapsed = (Date.now() - s.startedAt) / 1000;
    // Only jump if the slide is actually different or we're more than 3s behind
    if (s.idx !== slideIndex || elapsed > 3) {
      showSlide(presentation, s.idx, elapsed, false);
    }
  });
}

function attachListeners() {
  let monitorFirstFire = true;
  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), () => {
    if (monitorFirstFire) { monitorFirstFire = false; return; }
    debouncedPresentationChange(false);
  });

  let activeFirstFire = true;
  onValue(ref(db, "activePresentation"), async () => {
    if (activeFirstFire) { activeFirstFire = false; return; }
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;
    if (!pid) debouncedPresentationChange(false);
  });

  let assignedPid = null;
  let assignedPresentationUnsub = null;
  async function watchAssignedPresentation() {
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;

    if (pid === assignedPid) return;
    assignedPid = pid;

    if (assignedPresentationUnsub) { assignedPresentationUnsub(); assignedPresentationUnsub = null; }
    if (!pid) return;

    // Attach sync listener for new presentation
    attachSyncListener(pid);

    let presentationFirstFire = true;
    assignedPresentationUnsub = onValue(ref(db, `presentations/${pid}`), snap => {
      if (presentationFirstFire) { presentationFirstFire = false; return; }
      // Check if syncPlayback setting changed
      const p = snap.val();
      if (p) {
        const wasSynced = syncEnabled;
        syncEnabled = !!p.syncPlayback;
        if (syncEnabled && !wasSynced) attachSyncListener(pid);
      }
      debouncedPresentationChange(false);
    });
  }

  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), watchAssignedPresentation);

  let curFirstFire = true;
  onValue(ref(db, "presentations/current"), async () => {
    if (curFirstFire) { curFirstFire = false; return; }
    const monSnap = await get(ref(db, `monitors/${encodeURIComponent(monitorName)}`));
    const monData = monSnap.val();
    let pid = null;
    if (typeof monData === "string") pid = monData;
    else if (monData && typeof monData === "object") pid = monData.presentation || monData.assigned || monData.pid || null;
    if (!pid) debouncedPresentationChange(false);
  });

  let lastRefreshSignal = null;
  onValue(ref(db, "refreshSignal"), snap => {
    const val = snap.val();
    if (lastRefreshSignal === null) { lastRefreshSignal = val; return; }
    if (val !== lastRefreshSignal) { lastRefreshSignal = val; window.location.reload(); }
  });

  // ── Deletion watcher ───────────────────────────────────────────────────────
  // If this monitor's record is removed from the dashboard while the display
  // is running, wipe all local data and reload so it asks for a name again.
  let deletionFirstFire = true;
  onValue(ref(db, `monitors/${encodeURIComponent(monitorName)}`), snap => {
    if (deletionFirstFire) { deletionFirstFire = false; return; }
    if (snap.val() === null) resetToFirstRun();
  });
}

// ── Boot ───────────────────────────────────────────────────────────────────────
async function boot() {
  setProgress(0, "Connecting…");
  monitorName = await getMonitorName();
  if (!monitorName) return; // prompt was cancelled or reset in progress
  preloadTitle.textContent = monitorName;
  await registerPresence(monitorName);
  attachCommandListener(monitorName);
  attachListeners();
  await handlePresentationChange(false);
  // Attach sync listener after boot
  if (currentPresentationId) attachSyncListener(currentPresentationId);
}

boot();
</script>
</body>
</html>
